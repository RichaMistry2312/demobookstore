{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { r as registerInstance, h, H as Host } from './index-3fb5c139.js';\nimport { Logger, I18n } from '@aws-amplify/core';\nimport { M as MfaOption, A as AuthState } from './auth-types-78df304e.js';\nimport { Auth } from '@aws-amplify/auth';\nimport { T as Translations } from './Translations-c833f663.js';\nimport { S as SETUP_TOTP, i as SUCCESS, N as NO_AUTH_MODULE_FOUND } from './constants-d1abe7de.js';\nimport { d as dispatchAuthStateChangeEvent, o as onAuthUIStateChange, a as dispatchToastHubEvent } from './helpers-4f61e5ff.js';\nimport { c as checkContact } from './auth-helpers-bd096ca7.js';\nimport buffer from 'buffer';\nvar amplifyRadioButtonCss = \":host{--font-family:var(--amplify-font-family)}.radio-button{display:block;width:100%;padding:16px;font-size:var(--amplify-text-sm);font-family:var(--font-family)}.radio-button input{margin-right:12px}\";\nvar AmplifyRadioButton = /** @class */function () {\n  function AmplifyRadioButton(hostRef) {\n    registerInstance(this, hostRef);\n    /** (Optional) The placeholder for the input element.  Using hints is recommended, but placeholders can also be useful to convey information to users. */\n    this.placeholder = '';\n    /** If `true`, the radio button is selected. */\n    this.checked = false;\n    /** If `true`, the checkbox is disabled */\n    this.disabled = false;\n  }\n  AmplifyRadioButton.prototype.render = function () {\n    return h(\"span\", {\n      class: \"radio-button\"\n    }, h(\"input\", Object.assign({\n      type: \"radio\",\n      name: this.name,\n      value: this.value,\n      onInput: this.handleInputChange,\n      placeholder: this.placeholder,\n      id: this.fieldId,\n      checked: this.checked,\n      disabled: this.disabled\n    }, this.inputProps)), h(\"amplify-label\", {\n      htmlFor: this.fieldId\n    }, this.label));\n  };\n  return AmplifyRadioButton;\n}();\nAmplifyRadioButton.style = amplifyRadioButtonCss;\n// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\nvar canPromise = function () {\n  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;\n};\nvar toString = {}.toString;\nvar isarray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\nfunction typedArraySupport() {\n  // Can typed array instances be augmented?\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = {\n      __proto__: Uint8Array.prototype,\n      foo: function () {\n        return 42;\n      }\n    };\n    return arr.foo() === 42;\n  } catch (e) {\n    return false;\n  }\n}\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\nvar K_MAX_LENGTH = Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\nfunction Buffer(arg, offset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, offset, length);\n  }\n  if (typeof arg === 'number') {\n    return allocUnsafe(this, arg);\n  }\n  return from(this, arg, offset, length);\n}\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true,\n      enumerable: false,\n      writable: false\n    });\n  }\n}\nfunction checked(length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n  }\n  return length | 0;\n}\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\nfunction createBuffer(that, length) {\n  var buf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    buf = new Uint8Array(length);\n    buf.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    buf = that;\n    if (buf === null) {\n      buf = new Buffer(length);\n    }\n    buf.length = length;\n  }\n  return buf;\n}\nfunction allocUnsafe(that, size) {\n  var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      buf[i] = 0;\n    }\n  }\n  return buf;\n}\nfunction fromString(that, string) {\n  var length = byteLength(string) | 0;\n  var buf = createBuffer(that, length);\n  var actual = buf.write(string);\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n  }\n  return buf;\n}\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  var buf = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255;\n  }\n  return buf;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n  var buf;\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array);\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset);\n  } else {\n    buf = new Uint8Array(array, byteOffset, length);\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    buf.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    buf = fromArrayLike(that, buf);\n  }\n  return buf;\n}\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    var buf = createBuffer(that, len);\n    if (buf.length === 0) {\n      return buf;\n    }\n    obj.copy(buf, 0, 0, len);\n    return buf;\n  }\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n      return fromArrayLike(that, obj);\n    }\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n        // valid lead\n        leadSurrogate = codePoint;\n        continue;\n      }\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n    leadSurrogate = null;\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction byteLength(string) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n  var len = string.length;\n  if (len === 0) return 0;\n  return utf8ToBytes(string).length;\n}\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n  return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction from(that, value, offset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, offset, length);\n  }\n  if (typeof value === 'string') {\n    return fromString(that, value);\n  }\n  return fromObject(that, value);\n}\nBuffer.prototype.write = function write(string, offset, length) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, offset[, length])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n    } else {\n      length = undefined;\n    }\n  }\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n  return utf8Write(this, string, offset, length);\n};\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n  if (end < start) end = start;\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n  return newBuf;\n};\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0;\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds');\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n  var len = end - start;\n  var i;\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n  return len;\n};\nBuffer.prototype.fill = function fill(val, start, end) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n  if (end <= start) {\n    return this;\n  }\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n  if (!val) val = 0;\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : new Buffer(val);\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n  return this;\n};\nBuffer.concat = function concat(list, length) {\n  if (!isarray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n  if (list.length === 0) {\n    return createBuffer(null, 0);\n  }\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n  var buffer = allocUnsafe(null, length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\nBuffer.byteLength = byteLength;\nBuffer.prototype._isBuffer = true;\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\nvar alloc = function (size) {\n  var buffer = new Buffer(size);\n  buffer.fill(0);\n  return buffer;\n};\nvar from_1 = function (data) {\n  return new Buffer(data);\n};\nvar typedarrayBuffer = {\n  alloc: alloc,\n  from: from_1\n};\nvar toSJISFunction;\nvar CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nvar getSymbolSize = function getSymbolSize(version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined');\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40');\n  return version * 4 + 17;\n};\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nvar getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n  return CODEWORDS_COUNT[version];\n};\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nvar getBCHDigit = function (data) {\n  var digit = 0;\n  while (data !== 0) {\n    digit++;\n    data >>>= 1;\n  }\n  return digit;\n};\nvar setToSJISFunction = function setToSJISFunction(f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.');\n  }\n  toSJISFunction = f;\n};\nvar isKanjiModeEnabled = function () {\n  return typeof toSJISFunction !== 'undefined';\n};\nvar toSJIS = function toSJIS(kanji) {\n  return toSJISFunction(kanji);\n};\nvar utils = {\n  getSymbolSize: getSymbolSize,\n  getSymbolTotalCodewords: getSymbolTotalCodewords,\n  getBCHDigit: getBCHDigit,\n  setToSJISFunction: setToSJISFunction,\n  isKanjiModeEnabled: isKanjiModeEnabled,\n  toSJIS: toSJIS\n};\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function (path, base) {\n      return commonjsRequire();\n    }\n  }, fn(module, module.exports), module.exports;\n}\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\nvar errorCorrectionLevel = createCommonjsModule(function (module, exports) {\n  exports.L = {\n    bit: 1\n  };\n  exports.M = {\n    bit: 0\n  };\n  exports.Q = {\n    bit: 3\n  };\n  exports.H = {\n    bit: 2\n  };\n  function fromString(string) {\n    if (typeof string !== 'string') {\n      throw new Error('Param is not a string');\n    }\n    var lcStr = string.toLowerCase();\n    switch (lcStr) {\n      case 'l':\n      case 'low':\n        return exports.L;\n      case 'm':\n      case 'medium':\n        return exports.M;\n      case 'q':\n      case 'quartile':\n        return exports.Q;\n      case 'h':\n      case 'high':\n        return exports.H;\n      default:\n        throw new Error('Unknown EC Level: ' + string);\n    }\n  }\n  exports.isValid = function isValid(level) {\n    return level && typeof level.bit !== 'undefined' && level.bit >= 0 && level.bit < 4;\n  };\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\nfunction BitBuffer() {\n  this.buffer = [];\n  this.length = 0;\n}\nBitBuffer.prototype = {\n  get: function (index) {\n    var bufIndex = Math.floor(index / 8);\n    return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;\n  },\n  put: function (num, length) {\n    for (var i = 0; i < length; i++) {\n      this.putBit((num >>> length - i - 1 & 1) === 1);\n    }\n  },\n  getLengthInBits: function () {\n    return this.length;\n  },\n  putBit: function (bit) {\n    var bufIndex = Math.floor(this.length / 8);\n    if (this.buffer.length <= bufIndex) {\n      this.buffer.push(0);\n    }\n    if (bit) {\n      this.buffer[bufIndex] |= 0x80 >>> this.length % 8;\n    }\n    this.length++;\n  }\n};\nvar bitBuffer = BitBuffer;\n/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix(size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0');\n  }\n  this.size = size;\n  this.data = typedarrayBuffer.alloc(size * size);\n  this.reservedBit = typedarrayBuffer.alloc(size * size);\n}\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  var index = row * this.size + col;\n  this.data[index] = value;\n  if (reserved) this.reservedBit[index] = true;\n};\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col];\n};\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value;\n};\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col];\n};\nvar bitMatrix = BitMatrix;\nvar alignmentPattern = createCommonjsModule(function (module, exports) {\n  /**\n   * Alignment pattern are fixed reference pattern in defined positions\n   * in a matrix symbology, which enables the decode software to re-synchronise\n   * the coordinate mapping of the image modules in the event of moderate amounts\n   * of distortion of the image.\n   *\n   * Alignment patterns are present only in QR Code symbols of version 2 or larger\n   * and their number depends on the symbol version.\n   */\n  var getSymbolSize = utils.getSymbolSize;\n  /**\n   * Calculate the row/column coordinates of the center module of each alignment pattern\n   * for the specified QR Code version.\n   *\n   * The alignment patterns are positioned symmetrically on either side of the diagonal\n   * running from the top left corner of the symbol to the bottom right corner.\n   *\n   * Since positions are simmetrical only half of the coordinates are returned.\n   * Each item of the array will represent in turn the x and y coordinate.\n   * @see {@link getPositions}\n   *\n   * @param  {Number} version QR Code version\n   * @return {Array}          Array of coordinate\n   */\n  exports.getRowColCoords = function getRowColCoords(version) {\n    if (version === 1) return [];\n    var posCount = Math.floor(version / 7) + 2;\n    var size = getSymbolSize(version);\n    var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n    var positions = [size - 7]; // Last coord is always (size - 7)\n    for (var i = 1; i < posCount - 1; i++) {\n      positions[i] = positions[i - 1] - intervals;\n    }\n    positions.push(6); // First coord is always 6\n    return positions.reverse();\n  };\n  /**\n   * Returns an array containing the positions of each alignment pattern.\n   * Each array's element represent the center point of the pattern as (x, y) coordinates\n   *\n   * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n   * and filtering out the items that overlaps with finder pattern\n   *\n   * @example\n   * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n   * The alignment patterns, therefore, are to be centered on (row, column)\n   * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n   * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n   * and are not therefore used for alignment patterns.\n   *\n   * var pos = getPositions(7)\n   * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n   *\n   * @param  {Number} version QR Code version\n   * @return {Array}          Array of coordinates\n   */\n  exports.getPositions = function getPositions(version) {\n    var coords = [];\n    var pos = exports.getRowColCoords(version);\n    var posLength = pos.length;\n    for (var i = 0; i < posLength; i++) {\n      for (var j = 0; j < posLength; j++) {\n        // Skip if position is occupied by finder patterns\n        if (i === 0 && j === 0 ||\n        // top-left\n        i === 0 && j === posLength - 1 ||\n        // bottom-left\n        i === posLength - 1 && j === 0) {\n          // top-right\n          continue;\n        }\n        coords.push([pos[i], pos[j]]);\n      }\n    }\n    return coords;\n  };\n});\nvar getSymbolSize$1 = utils.getSymbolSize;\nvar FINDER_PATTERN_SIZE = 7;\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nvar getPositions = function getPositions(version) {\n  var size = getSymbolSize$1(version);\n  return [\n  // top-left\n  [0, 0],\n  // top-right\n  [size - FINDER_PATTERN_SIZE, 0],\n  // bottom-left\n  [0, size - FINDER_PATTERN_SIZE]];\n};\nvar finderPattern = {\n  getPositions: getPositions\n};\nvar maskPattern = createCommonjsModule(function (module, exports) {\n  /**\n   * Data mask pattern reference\n   * @type {Object}\n   */\n  exports.Patterns = {\n    PATTERN000: 0,\n    PATTERN001: 1,\n    PATTERN010: 2,\n    PATTERN011: 3,\n    PATTERN100: 4,\n    PATTERN101: 5,\n    PATTERN110: 6,\n    PATTERN111: 7\n  };\n  /**\n   * Weighted penalty scores for the undesirable features\n   * @type {Object}\n   */\n  var PenaltyScores = {\n    N1: 3,\n    N2: 3,\n    N3: 40,\n    N4: 10\n  };\n  /**\n   * Check if mask pattern value is valid\n   *\n   * @param  {Number}  mask    Mask pattern\n   * @return {Boolean}         true if valid, false otherwise\n   */\n  exports.isValid = function isValid(mask) {\n    return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;\n  };\n  /**\n   * Returns mask pattern from a value.\n   * If value is not valid, returns undefined\n   *\n   * @param  {Number|String} value        Mask pattern value\n   * @return {Number}                     Valid mask pattern or undefined\n   */\n  exports.from = function from(value) {\n    return exports.isValid(value) ? parseInt(value, 10) : undefined;\n  };\n  /**\n  * Find adjacent modules in row/column with the same color\n  * and assign a penalty value.\n  *\n  * Points: N1 + i\n  * i is the amount by which the number of adjacent modules of the same color exceeds 5\n  */\n  exports.getPenaltyN1 = function getPenaltyN1(data) {\n    var size = data.size;\n    var points = 0;\n    var sameCountCol = 0;\n    var sameCountRow = 0;\n    var lastCol = null;\n    var lastRow = null;\n    for (var row = 0; row < size; row++) {\n      sameCountCol = sameCountRow = 0;\n      lastCol = lastRow = null;\n      for (var col = 0; col < size; col++) {\n        var module = data.get(row, col);\n        if (module === lastCol) {\n          sameCountCol++;\n        } else {\n          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n          lastCol = module;\n          sameCountCol = 1;\n        }\n        module = data.get(col, row);\n        if (module === lastRow) {\n          sameCountRow++;\n        } else {\n          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n          lastRow = module;\n          sameCountRow = 1;\n        }\n      }\n      if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n      if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n    }\n    return points;\n  };\n  /**\n   * Find 2x2 blocks with the same color and assign a penalty value\n   *\n   * Points: N2 * (m - 1) * (n - 1)\n   */\n  exports.getPenaltyN2 = function getPenaltyN2(data) {\n    var size = data.size;\n    var points = 0;\n    for (var row = 0; row < size - 1; row++) {\n      for (var col = 0; col < size - 1; col++) {\n        var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);\n        if (last === 4 || last === 0) points++;\n      }\n    }\n    return points * PenaltyScores.N2;\n  };\n  /**\n   * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n   * preceded or followed by light area 4 modules wide\n   *\n   * Points: N3 * number of pattern found\n   */\n  exports.getPenaltyN3 = function getPenaltyN3(data) {\n    var size = data.size;\n    var points = 0;\n    var bitsCol = 0;\n    var bitsRow = 0;\n    for (var row = 0; row < size; row++) {\n      bitsCol = bitsRow = 0;\n      for (var col = 0; col < size; col++) {\n        bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);\n        if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;\n        bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);\n        if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;\n      }\n    }\n    return points * PenaltyScores.N3;\n  };\n  /**\n   * Calculate proportion of dark modules in entire symbol\n   *\n   * Points: N4 * k\n   *\n   * k is the rating of the deviation of the proportion of dark modules\n   * in the symbol from 50% in steps of 5%\n   */\n  exports.getPenaltyN4 = function getPenaltyN4(data) {\n    var darkCount = 0;\n    var modulesCount = data.data.length;\n    for (var i = 0; i < modulesCount; i++) darkCount += data.data[i];\n    var k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);\n    return k * PenaltyScores.N4;\n  };\n  /**\n   * Return mask value at given position\n   *\n   * @param  {Number} maskPattern Pattern reference value\n   * @param  {Number} i           Row\n   * @param  {Number} j           Column\n   * @return {Boolean}            Mask value\n   */\n  function getMaskAt(maskPattern, i, j) {\n    switch (maskPattern) {\n      case exports.Patterns.PATTERN000:\n        return (i + j) % 2 === 0;\n      case exports.Patterns.PATTERN001:\n        return i % 2 === 0;\n      case exports.Patterns.PATTERN010:\n        return j % 3 === 0;\n      case exports.Patterns.PATTERN011:\n        return (i + j) % 3 === 0;\n      case exports.Patterns.PATTERN100:\n        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n      case exports.Patterns.PATTERN101:\n        return i * j % 2 + i * j % 3 === 0;\n      case exports.Patterns.PATTERN110:\n        return (i * j % 2 + i * j % 3) % 2 === 0;\n      case exports.Patterns.PATTERN111:\n        return (i * j % 3 + (i + j) % 2) % 2 === 0;\n      default:\n        throw new Error('bad maskPattern:' + maskPattern);\n    }\n  }\n  /**\n   * Apply a mask pattern to a BitMatrix\n   *\n   * @param  {Number}    pattern Pattern reference number\n   * @param  {BitMatrix} data    BitMatrix data\n   */\n  exports.applyMask = function applyMask(pattern, data) {\n    var size = data.size;\n    for (var col = 0; col < size; col++) {\n      for (var row = 0; row < size; row++) {\n        if (data.isReserved(row, col)) continue;\n        data.xor(row, col, getMaskAt(pattern, row, col));\n      }\n    }\n  };\n  /**\n   * Returns the best mask pattern for data\n   *\n   * @param  {BitMatrix} data\n   * @return {Number} Mask pattern reference number\n   */\n  exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n    var numPatterns = Object.keys(exports.Patterns).length;\n    var bestPattern = 0;\n    var lowerPenalty = Infinity;\n    for (var p = 0; p < numPatterns; p++) {\n      setupFormatFunc(p);\n      exports.applyMask(p, data);\n      // Calculate penalty\n      var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);\n      // Undo previously applied mask\n      exports.applyMask(p, data);\n      if (penalty < lowerPenalty) {\n        lowerPenalty = penalty;\n        bestPattern = p;\n      }\n    }\n    return bestPattern;\n  };\n});\nvar EC_BLOCKS_TABLE = [\n// L  M  Q  H\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];\nvar EC_CODEWORDS_TABLE = [\n// L  M  Q  H\n7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];\n/**\n * Returns the number of error correction block that the QR Code should contain\n * for the specified version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction blocks\n */\nvar getBlocksCount = function getBlocksCount(version, errorCorrectionLevel$1) {\n  switch (errorCorrectionLevel$1) {\n    case errorCorrectionLevel.L:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n    case errorCorrectionLevel.M:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n    case errorCorrectionLevel.Q:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n    case errorCorrectionLevel.H:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n    default:\n      return undefined;\n  }\n};\n/**\n * Returns the number of error correction codewords to use for the specified\n * version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction codewords\n */\nvar getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel$1) {\n  switch (errorCorrectionLevel$1) {\n    case errorCorrectionLevel.L:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n    case errorCorrectionLevel.M:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n    case errorCorrectionLevel.Q:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n    case errorCorrectionLevel.H:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n    default:\n      return undefined;\n  }\n};\nvar errorCorrectionCode = {\n  getBlocksCount: getBlocksCount,\n  getTotalCodewordsCount: getTotalCodewordsCount\n};\nvar EXP_TABLE = typedarrayBuffer.alloc(512);\nvar LOG_TABLE = typedarrayBuffer.alloc(256);\n(function initTables() {\n  var x = 1;\n  for (var i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x;\n    LOG_TABLE[x] = i;\n    x <<= 1; // multiply by 2\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n    if (x & 0x100) {\n      // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D;\n    }\n  }\n  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n  for (i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255];\n  }\n})();\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar log = function log(n) {\n  if (n < 1) throw new Error('log(' + n + ')');\n  return LOG_TABLE[n];\n};\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar exp = function exp(n) {\n  return EXP_TABLE[n];\n};\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nvar mul = function mul(x, y) {\n  if (x === 0 || y === 0) return 0;\n  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n};\nvar galoisField = {\n  log: log,\n  exp: exp,\n  mul: mul\n};\nvar polynomial = createCommonjsModule(function (module, exports) {\n  /**\n   * Multiplies two polynomials inside Galois Field\n   *\n   * @param  {Buffer} p1 Polynomial\n   * @param  {Buffer} p2 Polynomial\n   * @return {Buffer}    Product of p1 and p2\n   */\n  exports.mul = function mul(p1, p2) {\n    var coeff = typedarrayBuffer.alloc(p1.length + p2.length - 1);\n    for (var i = 0; i < p1.length; i++) {\n      for (var j = 0; j < p2.length; j++) {\n        coeff[i + j] ^= galoisField.mul(p1[i], p2[j]);\n      }\n    }\n    return coeff;\n  };\n  /**\n   * Calculate the remainder of polynomials division\n   *\n   * @param  {Buffer} divident Polynomial\n   * @param  {Buffer} divisor  Polynomial\n   * @return {Buffer}          Remainder\n   */\n  exports.mod = function mod(divident, divisor) {\n    var result = typedarrayBuffer.from(divident);\n    while (result.length - divisor.length >= 0) {\n      var coeff = result[0];\n      for (var i = 0; i < divisor.length; i++) {\n        result[i] ^= galoisField.mul(divisor[i], coeff);\n      }\n      // remove all zeros from buffer head\n      var offset = 0;\n      while (offset < result.length && result[offset] === 0) offset++;\n      result = result.slice(offset);\n    }\n    return result;\n  };\n  /**\n   * Generate an irreducible generator polynomial of specified degree\n   * (used by Reed-Solomon encoder)\n   *\n   * @param  {Number} degree Degree of the generator polynomial\n   * @return {Buffer}        Buffer containing polynomial coefficients\n   */\n  exports.generateECPolynomial = function generateECPolynomial(degree) {\n    var poly = typedarrayBuffer.from([1]);\n    for (var i = 0; i < degree; i++) {\n      poly = exports.mul(poly, [1, galoisField.exp(i)]);\n    }\n    return poly;\n  };\n});\nvar Buffer$1 = buffer.Buffer;\nfunction ReedSolomonEncoder(degree) {\n  this.genPoly = undefined;\n  this.degree = degree;\n  if (this.degree) this.initialize(this.degree);\n}\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree;\n  this.genPoly = polynomial.generateECPolynomial(this.degree);\n};\n/**\n * Encodes a chunk of data\n *\n * @param  {Buffer} data Buffer containing input data\n * @return {Buffer}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode(data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized');\n  }\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  var pad = typedarrayBuffer.alloc(this.degree);\n  var paddedData = Buffer$1.concat([data, pad], data.length + this.degree);\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  var remainder = polynomial.mod(paddedData, this.genPoly);\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  var start = this.degree - remainder.length;\n  if (start > 0) {\n    var buff = typedarrayBuffer.alloc(this.degree);\n    remainder.copy(buff, start);\n    return buff;\n  }\n  return remainder;\n};\nvar reedSolomonEncoder = ReedSolomonEncoder;\n/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nvar isValid = function isValid(version) {\n  return !isNaN(version) && version >= 1 && version <= 40;\n};\nvar versionCheck = {\n  isValid: isValid\n};\nvar numeric = '[0-9]+';\nvar alphanumeric = '[A-Z $%*+\\\\-./:]+';\nvar kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' + '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' + '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' + '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';\nkanji = kanji.replace(/u/g, '\\\\u');\nvar byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+';\nvar KANJI = new RegExp(kanji, 'g');\nvar BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g');\nvar BYTE = new RegExp(byte, 'g');\nvar NUMERIC = new RegExp(numeric, 'g');\nvar ALPHANUMERIC = new RegExp(alphanumeric, 'g');\nvar TEST_KANJI = new RegExp('^' + kanji + '$');\nvar TEST_NUMERIC = new RegExp('^' + numeric + '$');\nvar TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$');\nvar testKanji = function testKanji(str) {\n  return TEST_KANJI.test(str);\n};\nvar testNumeric = function testNumeric(str) {\n  return TEST_NUMERIC.test(str);\n};\nvar testAlphanumeric = function testAlphanumeric(str) {\n  return TEST_ALPHANUMERIC.test(str);\n};\nvar regex = {\n  KANJI: KANJI,\n  BYTE_KANJI: BYTE_KANJI,\n  BYTE: BYTE,\n  NUMERIC: NUMERIC,\n  ALPHANUMERIC: ALPHANUMERIC,\n  testKanji: testKanji,\n  testNumeric: testNumeric,\n  testAlphanumeric: testAlphanumeric\n};\nvar mode = createCommonjsModule(function (module, exports) {\n  /**\n   * Numeric mode encodes data from the decimal digit set (0 - 9)\n   * (byte values 30HEX to 39HEX).\n   * Normally, 3 data characters are represented by 10 bits.\n   *\n   * @type {Object}\n   */\n  exports.NUMERIC = {\n    id: 'Numeric',\n    bit: 1 << 0,\n    ccBits: [10, 12, 14]\n  };\n  /**\n   * Alphanumeric mode encodes data from a set of 45 characters,\n   * i.e. 10 numeric digits (0 - 9),\n   *      26 alphabetic characters (A - Z),\n   *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n   * Normally, two input characters are represented by 11 bits.\n   *\n   * @type {Object}\n   */\n  exports.ALPHANUMERIC = {\n    id: 'Alphanumeric',\n    bit: 1 << 1,\n    ccBits: [9, 11, 13]\n  };\n  /**\n   * In byte mode, data is encoded at 8 bits per character.\n   *\n   * @type {Object}\n   */\n  exports.BYTE = {\n    id: 'Byte',\n    bit: 1 << 2,\n    ccBits: [8, 16, 16]\n  };\n  /**\n   * The Kanji mode efficiently encodes Kanji characters in accordance with\n   * the Shift JIS system based on JIS X 0208.\n   * The Shift JIS values are shifted from the JIS X 0208 values.\n   * JIS X 0208 gives details of the shift coded representation.\n   * Each two-byte character value is compacted to a 13-bit binary codeword.\n   *\n   * @type {Object}\n   */\n  exports.KANJI = {\n    id: 'Kanji',\n    bit: 1 << 3,\n    ccBits: [8, 10, 12]\n  };\n  /**\n   * Mixed mode will contain a sequences of data in a combination of any of\n   * the modes described above\n   *\n   * @type {Object}\n   */\n  exports.MIXED = {\n    bit: -1\n  };\n  /**\n   * Returns the number of bits needed to store the data length\n   * according to QR Code specifications.\n   *\n   * @param  {Mode}   mode    Data mode\n   * @param  {Number} version QR Code version\n   * @return {Number}         Number of bits\n   */\n  exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n    if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);\n    if (!versionCheck.isValid(version)) {\n      throw new Error('Invalid version: ' + version);\n    }\n    if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n    return mode.ccBits[2];\n  };\n  /**\n   * Returns the most efficient mode to store the specified data\n   *\n   * @param  {String} dataStr Input data string\n   * @return {Mode}           Best mode\n   */\n  exports.getBestModeForData = function getBestModeForData(dataStr) {\n    if (regex.testNumeric(dataStr)) return exports.NUMERIC;else if (regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n  };\n  /**\n   * Return mode name as string\n   *\n   * @param {Mode} mode Mode object\n   * @returns {String}  Mode name\n   */\n  exports.toString = function toString(mode) {\n    if (mode && mode.id) return mode.id;\n    throw new Error('Invalid mode');\n  };\n  /**\n   * Check if input param is a valid mode object\n   *\n   * @param   {Mode}    mode Mode object\n   * @returns {Boolean} True if valid mode, false otherwise\n   */\n  exports.isValid = function isValid(mode) {\n    return mode && mode.bit && mode.ccBits;\n  };\n  /**\n   * Get mode object from its name\n   *\n   * @param   {String} string Mode name\n   * @returns {Mode}          Mode object\n   */\n  function fromString(string) {\n    if (typeof string !== 'string') {\n      throw new Error('Param is not a string');\n    }\n    var lcStr = string.toLowerCase();\n    switch (lcStr) {\n      case 'numeric':\n        return exports.NUMERIC;\n      case 'alphanumeric':\n        return exports.ALPHANUMERIC;\n      case 'kanji':\n        return exports.KANJI;\n      case 'byte':\n        return exports.BYTE;\n      default:\n        throw new Error('Unknown mode: ' + string);\n    }\n  }\n  /**\n   * Returns mode from a value.\n   * If value is not a valid mode, returns defaultValue\n   *\n   * @param  {Mode|String} value        Encoding mode\n   * @param  {Mode}        defaultValue Fallback value\n   * @return {Mode}                     Encoding mode\n   */\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\nvar version = createCommonjsModule(function (module, exports) {\n  // Generator polynomial used to encode version information\n  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n  var G18_BCH = utils.getBCHDigit(G18);\n  function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n        return currentVersion;\n      }\n    }\n    return undefined;\n  }\n  function getReservedBitsCount(mode$1, version) {\n    // Character count indicator + mode indicator bits\n    return mode.getCharCountIndicator(mode$1, version) + 4;\n  }\n  function getTotalBitsFromDataArray(segments, version) {\n    var totalBits = 0;\n    segments.forEach(function (data) {\n      var reservedBits = getReservedBitsCount(data.mode, version);\n      totalBits += reservedBits + data.getBitsLength();\n    });\n    return totalBits;\n  }\n  function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      var length = getTotalBitsFromDataArray(segments, currentVersion);\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode.MIXED)) {\n        return currentVersion;\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Returns version number from a value.\n   * If value is not a valid version, returns defaultValue\n   *\n   * @param  {Number|String} value        QR Code version\n   * @param  {Number}        defaultValue Fallback value\n   * @return {Number}                     QR Code version number\n   */\n  exports.from = function from(value, defaultValue) {\n    if (versionCheck.isValid(value)) {\n      return parseInt(value, 10);\n    }\n    return defaultValue;\n  };\n  /**\n   * Returns how much data can be stored with the specified QR code version\n   * and error correction level\n   *\n   * @param  {Number} version              QR Code version (1-40)\n   * @param  {Number} errorCorrectionLevel Error correction level\n   * @param  {Mode}   mode                 Data mode\n   * @return {Number}                      Quantity of storable data\n   */\n  exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode$1) {\n    if (!versionCheck.isValid(version)) {\n      throw new Error('Invalid QR Code version');\n    }\n    // Use Byte mode as default\n    if (typeof mode$1 === 'undefined') mode$1 = mode.BYTE;\n    // Total codewords for this QR code version (Data + Error correction)\n    var totalCodewords = utils.getSymbolTotalCodewords(version);\n    // Total number of error correction codewords\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    // Total number of data codewords\n    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    if (mode$1 === mode.MIXED) return dataTotalCodewordsBits;\n    var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode$1, version);\n    // Return max number of storable codewords\n    switch (mode$1) {\n      case mode.NUMERIC:\n        return Math.floor(usableBits / 10 * 3);\n      case mode.ALPHANUMERIC:\n        return Math.floor(usableBits / 11 * 2);\n      case mode.KANJI:\n        return Math.floor(usableBits / 13);\n      case mode.BYTE:\n      default:\n        return Math.floor(usableBits / 8);\n    }\n  };\n  /**\n   * Returns the minimum version needed to contain the amount of data\n   *\n   * @param  {Segment} data                    Segment of data\n   * @param  {Number} [errorCorrectionLevel=H] Error correction level\n   * @param  {Mode} mode                       Data mode\n   * @return {Number}                          QR Code version\n   */\n  exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel$1) {\n    var seg;\n    var ecl = errorCorrectionLevel.from(errorCorrectionLevel$1, errorCorrectionLevel.M);\n    if (isarray(data)) {\n      if (data.length > 1) {\n        return getBestVersionForMixedData(data, ecl);\n      }\n      if (data.length === 0) {\n        return 1;\n      }\n      seg = data[0];\n    } else {\n      seg = data;\n    }\n    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n  };\n  /**\n   * Returns version information with relative error correction bits\n   *\n   * The version information is included in QR Code symbols of version 7 or larger.\n   * It consists of an 18-bit sequence containing 6 data bits,\n   * with 12 error correction bits calculated using the (18, 6) Golay code.\n   *\n   * @param  {Number} version QR Code version\n   * @return {Number}         Encoded version info bits\n   */\n  exports.getEncodedBits = function getEncodedBits(version) {\n    if (!versionCheck.isValid(version) || version < 7) {\n      throw new Error('Invalid QR Code version');\n    }\n    var d = version << 12;\n    while (utils.getBCHDigit(d) - G18_BCH >= 0) {\n      d ^= G18 << utils.getBCHDigit(d) - G18_BCH;\n    }\n    return version << 12 | d;\n  };\n});\nvar G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\nvar G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\nvar G15_BCH = utils.getBCHDigit(G15);\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nvar getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n  var data = errorCorrectionLevel.bit << 3 | mask;\n  var d = data << 10;\n  while (utils.getBCHDigit(d) - G15_BCH >= 0) {\n    d ^= G15 << utils.getBCHDigit(d) - G15_BCH;\n  }\n  // xor final data with mask pattern in order to ensure that\n  // no combination of Error Correction Level and data mask pattern\n  // will result in an all-zero data string\n  return (data << 10 | d) ^ G15_MASK;\n};\nvar formatInfo = {\n  getEncodedBits: getEncodedBits\n};\nfunction NumericData(data) {\n  this.mode = mode.NUMERIC;\n  this.data = data.toString();\n}\nNumericData.getBitsLength = function getBitsLength(length) {\n  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);\n};\nNumericData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\nNumericData.prototype.getBitsLength = function getBitsLength() {\n  return NumericData.getBitsLength(this.data.length);\n};\nNumericData.prototype.write = function write(bitBuffer) {\n  var i, group, value;\n  // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3);\n    value = parseInt(group, 10);\n    bitBuffer.put(value, 10);\n  }\n  // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n  var remainingNum = this.data.length - i;\n  if (remainingNum > 0) {\n    group = this.data.substr(i);\n    value = parseInt(group, 10);\n    bitBuffer.put(value, remainingNum * 3 + 1);\n  }\n};\nvar numericData = NumericData;\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nvar ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];\nfunction AlphanumericData(data) {\n  this.mode = mode.ALPHANUMERIC;\n  this.data = data;\n}\nAlphanumericData.getBitsLength = function getBitsLength(length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2);\n};\nAlphanumericData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\nAlphanumericData.prototype.getBitsLength = function getBitsLength() {\n  return AlphanumericData.getBitsLength(this.data.length);\n};\nAlphanumericData.prototype.write = function write(bitBuffer) {\n  var i;\n  // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;\n    // The character value of the second digit is added to the product\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);\n    // The sum is then stored as 11-bit binary number\n    bitBuffer.put(value, 11);\n  }\n  // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n  }\n};\nvar alphanumericData = AlphanumericData;\nfunction ByteData(data) {\n  this.mode = mode.BYTE;\n  this.data = typedarrayBuffer.from(data);\n}\nByteData.getBitsLength = function getBitsLength(length) {\n  return length * 8;\n};\nByteData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\nByteData.prototype.getBitsLength = function getBitsLength() {\n  return ByteData.getBitsLength(this.data.length);\n};\nByteData.prototype.write = function (bitBuffer) {\n  for (var i = 0, l = this.data.length; i < l; i++) {\n    bitBuffer.put(this.data[i], 8);\n  }\n};\nvar byteData = ByteData;\nfunction KanjiData(data) {\n  this.mode = mode.KANJI;\n  this.data = data;\n}\nKanjiData.getBitsLength = function getBitsLength(length) {\n  return length * 13;\n};\nKanjiData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\nKanjiData.prototype.getBitsLength = function getBitsLength() {\n  return KanjiData.getBitsLength(this.data.length);\n};\nKanjiData.prototype.write = function (bitBuffer) {\n  var i;\n  // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n  // These byte values are shifted from the JIS X 0208 values.\n  // JIS X 0208 gives details of the shift coded representation.\n  for (i = 0; i < this.data.length; i++) {\n    var value = utils.toSJIS(this.data[i]);\n    // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n    if (value >= 0x8140 && value <= 0x9FFC) {\n      // Subtract 0x8140 from Shift JIS value\n      value -= 0x8140;\n      // For characters with Shift JIS values from 0xE040 to 0xEBBF\n    } else if (value >= 0xE040 && value <= 0xEBBF) {\n      // Subtract 0xC140 from Shift JIS value\n      value -= 0xC140;\n    } else {\n      throw new Error('Invalid SJIS character: ' + this.data[i] + '\\n' + 'Make sure your charset is UTF-8');\n    }\n    // Multiply most significant byte of result by 0xC0\n    // and add least significant byte to product\n    value = (value >>> 8 & 0xff) * 0xC0 + (value & 0xff);\n    // Convert result to a 13-bit binary string\n    bitBuffer.put(value, 13);\n  }\n};\nvar kanjiData = KanjiData;\nvar dijkstra_1 = createCommonjsModule(function (module) {\n  /******************************************************************************\n   * Created 2008-08-19.\n   *\n   * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n   *\n   * Copyright (C) 2008\n   *   Wyatt Baldwin <self@wyattbaldwin.com>\n   *   All rights reserved\n   *\n   * Licensed under the MIT license.\n   *\n   *   http://www.opensource.org/licenses/mit-license.php\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   *****************************************************************************/\n  var dijkstra = {\n    single_source_shortest_paths: function (graph, s, d) {\n      // Predecessor map for each node that has been encountered.\n      // node ID => predecessor node ID\n      var predecessors = {};\n      // Costs of shortest paths from s to all nodes encountered.\n      // node ID => cost\n      var costs = {};\n      costs[s] = 0;\n      // Costs of shortest paths from s to all nodes encountered; differs from\n      // `costs` in that it provides easy access to the node that currently has\n      // the known shortest path from s.\n      // XXX: Do we actually need both `costs` and `open`?\n      var open = dijkstra.PriorityQueue.make();\n      open.push(s, 0);\n      var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n      while (!open.empty()) {\n        // In the nodes remaining in graph that have a known cost from s,\n        // find the node, u, that currently has the shortest path from s.\n        closest = open.pop();\n        u = closest.value;\n        cost_of_s_to_u = closest.cost;\n        // Get nodes adjacent to u...\n        adjacent_nodes = graph[u] || {};\n        // ...and explore the edges that connect u to those nodes, updating\n        // the cost of the shortest paths to any or all of those nodes as\n        // necessary. v is the node across the current edge from u.\n        for (v in adjacent_nodes) {\n          if (adjacent_nodes.hasOwnProperty(v)) {\n            // Get the cost of the edge running from u to v.\n            cost_of_e = adjacent_nodes[v];\n            // Cost of s to u plus the cost of u to v across e--this is *a*\n            // cost from s to v that may or may not be less than the current\n            // known cost to v.\n            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n            // If we haven't visited v yet OR if the current known cost from s to\n            // v is greater than the new cost we just found (cost of s to u plus\n            // cost of u to v across e), update v's cost in the cost list and\n            // update v's predecessor in the predecessor list (it's now u).\n            cost_of_s_to_v = costs[v];\n            first_visit = typeof costs[v] === 'undefined';\n            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n              costs[v] = cost_of_s_to_u_plus_cost_of_e;\n              open.push(v, cost_of_s_to_u_plus_cost_of_e);\n              predecessors[v] = u;\n            }\n          }\n        }\n      }\n      if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n        var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n        throw new Error(msg);\n      }\n      return predecessors;\n    },\n    extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n      var nodes = [];\n      var u = d;\n      while (u) {\n        nodes.push(u);\n        u = predecessors[u];\n      }\n      nodes.reverse();\n      return nodes;\n    },\n    find_path: function (graph, s, d) {\n      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n    },\n    /**\n     * A very naive priority queue implementation.\n     */\n    PriorityQueue: {\n      make: function (opts) {\n        var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n        opts = opts || {};\n        for (key in T) {\n          if (T.hasOwnProperty(key)) {\n            t[key] = T[key];\n          }\n        }\n        t.queue = [];\n        t.sorter = opts.sorter || T.default_sorter;\n        return t;\n      },\n      default_sorter: function (a, b) {\n        return a.cost - b.cost;\n      },\n      /**\n       * Add a new item to the queue and ensure the highest priority element\n       * is at the front of the queue.\n       */\n      push: function (value, cost) {\n        var item = {\n          value: value,\n          cost: cost\n        };\n        this.queue.push(item);\n        this.queue.sort(this.sorter);\n      },\n      /**\n       * Return the highest priority element in the queue.\n       */\n      pop: function () {\n        return this.queue.shift();\n      },\n      empty: function () {\n        return this.queue.length === 0;\n      }\n    }\n  };\n  // node.js module exports\n  {\n    module.exports = dijkstra;\n  }\n});\nvar segments = createCommonjsModule(function (module, exports) {\n  /**\n   * Returns UTF8 byte length\n   *\n   * @param  {String} str Input string\n   * @return {Number}     Number of byte\n   */\n  function getStringByteLength(str) {\n    return unescape(encodeURIComponent(str)).length;\n  }\n  /**\n   * Get a list of segments of the specified mode\n   * from a string\n   *\n   * @param  {Mode}   mode Segment mode\n   * @param  {String} str  String to process\n   * @return {Array}       Array of object with segments data\n   */\n  function getSegments(regex, mode, str) {\n    var segments = [];\n    var result;\n    while ((result = regex.exec(str)) !== null) {\n      segments.push({\n        data: result[0],\n        index: result.index,\n        mode: mode,\n        length: result[0].length\n      });\n    }\n    return segments;\n  }\n  /**\n   * Extracts a series of segments with the appropriate\n   * modes from a string\n   *\n   * @param  {String} dataStr Input string\n   * @return {Array}          Array of object with segments data\n   */\n  function getSegmentsFromString(dataStr) {\n    var numSegs = getSegments(regex.NUMERIC, mode.NUMERIC, dataStr);\n    var alphaNumSegs = getSegments(regex.ALPHANUMERIC, mode.ALPHANUMERIC, dataStr);\n    var byteSegs;\n    var kanjiSegs;\n    if (utils.isKanjiModeEnabled()) {\n      byteSegs = getSegments(regex.BYTE, mode.BYTE, dataStr);\n      kanjiSegs = getSegments(regex.KANJI, mode.KANJI, dataStr);\n    } else {\n      byteSegs = getSegments(regex.BYTE_KANJI, mode.BYTE, dataStr);\n      kanjiSegs = [];\n    }\n    var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n    return segs.sort(function (s1, s2) {\n      return s1.index - s2.index;\n    }).map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      };\n    });\n  }\n  /**\n   * Returns how many bits are needed to encode a string of\n   * specified length with the specified mode\n   *\n   * @param  {Number} length String length\n   * @param  {Mode} mode     Segment mode\n   * @return {Number}        Bit length\n   */\n  function getSegmentBitsLength(length, mode$1) {\n    switch (mode$1) {\n      case mode.NUMERIC:\n        return numericData.getBitsLength(length);\n      case mode.ALPHANUMERIC:\n        return alphanumericData.getBitsLength(length);\n      case mode.KANJI:\n        return kanjiData.getBitsLength(length);\n      case mode.BYTE:\n        return byteData.getBitsLength(length);\n    }\n  }\n  /**\n   * Merges adjacent segments which have the same mode\n   *\n   * @param  {Array} segs Array of object with segments data\n   * @return {Array}      Array of object with segments data\n   */\n  function mergeSegments(segs) {\n    return segs.reduce(function (acc, curr) {\n      var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n      if (prevSeg && prevSeg.mode === curr.mode) {\n        acc[acc.length - 1].data += curr.data;\n        return acc;\n      }\n      acc.push(curr);\n      return acc;\n    }, []);\n  }\n  /**\n   * Generates a list of all possible nodes combination which\n   * will be used to build a segments graph.\n   *\n   * Nodes are divided by groups. Each group will contain a list of all the modes\n   * in which is possible to encode the given text.\n   *\n   * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n   * The group for '12345' will contain then 3 objects, one for each\n   * possible encoding mode.\n   *\n   * Each node represents a possible segment.\n   *\n   * @param  {Array} segs Array of object with segments data\n   * @return {Array}      Array of object with segments data\n   */\n  function buildNodes(segs) {\n    var nodes = [];\n    for (var i = 0; i < segs.length; i++) {\n      var seg = segs[i];\n      switch (seg.mode) {\n        case mode.NUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: mode.ALPHANUMERIC,\n            length: seg.length\n          }, {\n            data: seg.data,\n            mode: mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n        case mode.ALPHANUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n        case mode.KANJI:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n          break;\n        case mode.BYTE:\n          nodes.push([{\n            data: seg.data,\n            mode: mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n      }\n    }\n    return nodes;\n  }\n  /**\n   * Builds a graph from a list of nodes.\n   * All segments in each node group will be connected with all the segments of\n   * the next group and so on.\n   *\n   * At each connection will be assigned a weight depending on the\n   * segment's byte length.\n   *\n   * @param  {Array} nodes    Array of object with segments data\n   * @param  {Number} version QR Code version\n   * @return {Object}         Graph of all possible segments\n   */\n  function buildGraph(nodes, version) {\n    var table = {};\n    var graph = {\n      'start': {}\n    };\n    var prevNodeIds = ['start'];\n    for (var i = 0; i < nodes.length; i++) {\n      var nodeGroup = nodes[i];\n      var currentNodeIds = [];\n      for (var j = 0; j < nodeGroup.length; j++) {\n        var node = nodeGroup[j];\n        var key = '' + i + j;\n        currentNodeIds.push(key);\n        table[key] = {\n          node: node,\n          lastCount: 0\n        };\n        graph[key] = {};\n        for (var n = 0; n < prevNodeIds.length; n++) {\n          var prevNodeId = prevNodeIds[n];\n          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n            table[prevNodeId].lastCount += node.length;\n          } else {\n            if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + mode.getCharCountIndicator(node.mode, version); // switch cost\n          }\n        }\n      }\n      prevNodeIds = currentNodeIds;\n    }\n    for (n = 0; n < prevNodeIds.length; n++) {\n      graph[prevNodeIds[n]]['end'] = 0;\n    }\n    return {\n      map: graph,\n      table: table\n    };\n  }\n  /**\n   * Builds a segment from a specified data and mode.\n   * If a mode is not specified, the more suitable will be used.\n   *\n   * @param  {String} data             Input data\n   * @param  {Mode | String} modesHint Data mode\n   * @return {Segment}                 Segment\n   */\n  function buildSingleSegment(data, modesHint) {\n    var mode$1;\n    var bestMode = mode.getBestModeForData(data);\n    mode$1 = mode.from(modesHint, bestMode);\n    // Make sure data can be encoded\n    if (mode$1 !== mode.BYTE && mode$1.bit < bestMode.bit) {\n      throw new Error('\"' + data + '\"' + ' cannot be encoded with mode ' + mode.toString(mode$1) + '.\\n Suggested mode is: ' + mode.toString(bestMode));\n    }\n    // Use Mode.BYTE if Kanji support is disabled\n    if (mode$1 === mode.KANJI && !utils.isKanjiModeEnabled()) {\n      mode$1 = mode.BYTE;\n    }\n    switch (mode$1) {\n      case mode.NUMERIC:\n        return new numericData(data);\n      case mode.ALPHANUMERIC:\n        return new alphanumericData(data);\n      case mode.KANJI:\n        return new kanjiData(data);\n      case mode.BYTE:\n        return new byteData(data);\n    }\n  }\n  /**\n   * Builds a list of segments from an array.\n   * Array can contain Strings or Objects with segment's info.\n   *\n   * For each item which is a string, will be generated a segment with the given\n   * string and the more appropriate encoding mode.\n   *\n   * For each item which is an object, will be generated a segment with the given\n   * data and mode.\n   * Objects must contain at least the property \"data\".\n   * If property \"mode\" is not present, the more suitable mode will be used.\n   *\n   * @param  {Array} array Array of objects with segments data\n   * @return {Array}       Array of Segments\n   */\n  exports.fromArray = function fromArray(array) {\n    return array.reduce(function (acc, seg) {\n      if (typeof seg === 'string') {\n        acc.push(buildSingleSegment(seg, null));\n      } else if (seg.data) {\n        acc.push(buildSingleSegment(seg.data, seg.mode));\n      }\n      return acc;\n    }, []);\n  };\n  /**\n   * Builds an optimized sequence of segments from a string,\n   * which will produce the shortest possible bitstream.\n   *\n   * @param  {String} data    Input string\n   * @param  {Number} version QR Code version\n   * @return {Array}          Array of segments\n   */\n  exports.fromString = function fromString(data, version) {\n    var segs = getSegmentsFromString(data, utils.isKanjiModeEnabled());\n    var nodes = buildNodes(segs);\n    var graph = buildGraph(nodes, version);\n    var path = dijkstra_1.find_path(graph.map, 'start', 'end');\n    var optimizedSegs = [];\n    for (var i = 1; i < path.length - 1; i++) {\n      optimizedSegs.push(graph.table[path[i]].node);\n    }\n    return exports.fromArray(mergeSegments(optimizedSegs));\n  };\n  /**\n   * Splits a string in various segments with the modes which\n   * best represent their content.\n   * The produced segments are far from being optimized.\n   * The output of this function is only used to estimate a QR Code version\n   * which may contain the data.\n   *\n   * @param  {string} data Input string\n   * @return {Array}       Array of segments\n   */\n  exports.rawSplit = function rawSplit(data) {\n    return exports.fromArray(getSegmentsFromString(data, utils.isKanjiModeEnabled()));\n  };\n});\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern(matrix, version) {\n  var size = matrix.size;\n  var pos = finderPattern.getPositions(version);\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0];\n    var col = pos[i][1];\n    for (var r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue;\n      for (var c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue;\n        if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern(matrix) {\n  var size = matrix.size;\n  for (var r = 8; r < size - 8; r++) {\n    var value = r % 2 === 0;\n    matrix.set(r, 6, value, true);\n    matrix.set(6, r, value, true);\n  }\n}\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern(matrix, version) {\n  var pos = alignmentPattern.getPositions(version);\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0];\n    var col = pos[i][1];\n    for (var r = -2; r <= 2; r++) {\n      for (var c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo(matrix, version$1) {\n  var size = matrix.size;\n  var bits = version.getEncodedBits(version$1);\n  var row, col, mod;\n  for (var i = 0; i < 18; i++) {\n    row = Math.floor(i / 3);\n    col = i % 3 + size - 8 - 3;\n    mod = (bits >> i & 1) === 1;\n    matrix.set(row, col, mod, true);\n    matrix.set(col, row, mod, true);\n  }\n}\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n  var size = matrix.size;\n  var bits = formatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n  var i, mod;\n  for (i = 0; i < 15; i++) {\n    mod = (bits >> i & 1) === 1;\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true);\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true);\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true);\n    }\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true);\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true);\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true);\n    }\n  }\n  // fixed module\n  matrix.set(size - 8, 8, 1, true);\n}\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\nfunction setupData(matrix, data) {\n  var size = matrix.size;\n  var inc = -1;\n  var row = size - 1;\n  var bitIndex = 7;\n  var byteIndex = 0;\n  for (var col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--;\n    while (true) {\n      for (var c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          var dark = false;\n          if (byteIndex < data.length) {\n            dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n          }\n          matrix.set(row, col - c, dark);\n          bitIndex--;\n          if (bitIndex === -1) {\n            byteIndex++;\n            bitIndex = 7;\n          }\n        }\n      }\n      row += inc;\n      if (row < 0 || size <= row) {\n        row -= inc;\n        inc = -inc;\n        break;\n      }\n    }\n  }\n}\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\nfunction createData(version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  var buffer = new bitBuffer();\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4);\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), mode.getCharCountIndicator(data.mode, version));\n    // add binary data sequence to buffer\n    data.write(buffer);\n  });\n  // Calculate required number of bits\n  var totalCodewords = utils.getSymbolTotalCodewords(version);\n  var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4);\n  }\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0);\n  }\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n  for (var i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n  }\n  return createCodewords(buffer, version, errorCorrectionLevel);\n}\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\nfunction createCodewords(bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  var totalCodewords = utils.getSymbolTotalCodewords(version);\n  // Total number of error correction codewords\n  var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n  // Total number of data codewords\n  var dataTotalCodewords = totalCodewords - ecTotalCodewords;\n  // Total number of blocks\n  var ecTotalBlocks = errorCorrectionCode.getBlocksCount(version, errorCorrectionLevel);\n  // Calculate how many blocks each group should contain\n  var blocksInGroup2 = totalCodewords % ecTotalBlocks;\n  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;\n  // Number of EC codewords is the same for both groups\n  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  var rs = new reedSolomonEncoder(ecCount);\n  var offset = 0;\n  var dcData = new Array(ecTotalBlocks);\n  var ecData = new Array(ecTotalBlocks);\n  var maxDataSize = 0;\n  var buffer = typedarrayBuffer.from(bitBuffer.buffer);\n  // Divide the buffer into the required number of blocks\n  for (var b = 0; b < ecTotalBlocks; b++) {\n    var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize);\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b]);\n    offset += dataSize;\n    maxDataSize = Math.max(maxDataSize, dataSize);\n  }\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  var data = typedarrayBuffer.alloc(totalCodewords);\n  var index = 0;\n  var i, r;\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i];\n      }\n    }\n  }\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i];\n    }\n  }\n  return data;\n}\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol(data, version$1, errorCorrectionLevel, maskPattern$1) {\n  var segments$1;\n  if (isarray(data)) {\n    segments$1 = segments.fromArray(data);\n  } else if (typeof data === 'string') {\n    var estimatedVersion = version$1;\n    if (!estimatedVersion) {\n      var rawSegments = segments.rawSplit(data);\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n    }\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments$1 = segments.fromString(data, estimatedVersion || 40);\n  } else {\n    throw new Error('Invalid data');\n  }\n  // Get the min version that can contain data\n  var bestVersion = version.getBestVersionForData(segments$1, errorCorrectionLevel);\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code');\n  }\n  // If not specified, use min version as default\n  if (!version$1) {\n    version$1 = bestVersion;\n    // Check if the specified version can contain the data\n  } else if (version$1 < bestVersion) {\n    throw new Error('\\n' + 'The chosen QR Code version cannot contain this amount of data.\\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n  }\n  var dataBits = createData(version$1, errorCorrectionLevel, segments$1);\n  // Allocate matrix buffer\n  var moduleCount = utils.getSymbolSize(version$1);\n  var modules = new bitMatrix(moduleCount);\n  // Add function modules\n  setupFinderPattern(modules, version$1);\n  setupTimingPattern(modules);\n  setupAlignmentPattern(modules, version$1);\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0);\n  if (version$1 >= 7) {\n    setupVersionInfo(modules, version$1);\n  }\n  // Add data codewords\n  setupData(modules, dataBits);\n  if (isNaN(maskPattern$1)) {\n    // Find best mask pattern\n    maskPattern$1 = maskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n  }\n  // Apply mask pattern\n  maskPattern.applyMask(maskPattern$1, modules);\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern$1);\n  return {\n    modules: modules,\n    version: version$1,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern$1,\n    segments: segments$1\n  };\n}\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nvar create = function create(data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text');\n  }\n  var errorCorrectionLevel$1 = errorCorrectionLevel.M;\n  var version$1;\n  var mask;\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel$1 = errorCorrectionLevel.from(options.errorCorrectionLevel, errorCorrectionLevel.M);\n    version$1 = version.from(options.version);\n    mask = maskPattern.from(options.maskPattern);\n    if (options.toSJISFunc) {\n      utils.setToSJISFunction(options.toSJISFunc);\n    }\n  }\n  return createSymbol(data, version$1, errorCorrectionLevel$1, mask);\n};\nvar qrcode = {\n  create: create\n};\nvar utils$1 = createCommonjsModule(function (module, exports) {\n  function hex2rgba(hex) {\n    if (typeof hex === 'number') {\n      hex = hex.toString();\n    }\n    if (typeof hex !== 'string') {\n      throw new Error('Color should be defined as hex string');\n    }\n    var hexCode = hex.slice().replace('#', '').split('');\n    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n      throw new Error('Invalid hex color: ' + hex);\n    }\n    // Convert from short to long form (fff -> ffffff)\n    if (hexCode.length === 3 || hexCode.length === 4) {\n      hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n        return [c, c];\n      }));\n    }\n    // Add default alpha value\n    if (hexCode.length === 6) hexCode.push('F', 'F');\n    var hexValue = parseInt(hexCode.join(''), 16);\n    return {\n      r: hexValue >> 24 & 255,\n      g: hexValue >> 16 & 255,\n      b: hexValue >> 8 & 255,\n      a: hexValue & 255,\n      hex: '#' + hexCode.slice(0, 6).join('')\n    };\n  }\n  exports.getOptions = function getOptions(options) {\n    if (!options) options = {};\n    if (!options.color) options.color = {};\n    var margin = typeof options.margin === 'undefined' || options.margin === null || options.margin < 0 ? 4 : options.margin;\n    var width = options.width && options.width >= 21 ? options.width : undefined;\n    var scale = options.scale || 4;\n    return {\n      width: width,\n      scale: width ? 4 : scale,\n      margin: margin,\n      color: {\n        dark: hex2rgba(options.color.dark || '#000000ff'),\n        light: hex2rgba(options.color.light || '#ffffffff')\n      },\n      type: options.type,\n      rendererOpts: options.rendererOpts || {}\n    };\n  };\n  exports.getScale = function getScale(qrSize, opts) {\n    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;\n  };\n  exports.getImageWidth = function getImageWidth(qrSize, opts) {\n    var scale = exports.getScale(qrSize, opts);\n    return Math.floor((qrSize + opts.margin * 2) * scale);\n  };\n  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n    var size = qr.modules.size;\n    var data = qr.modules.data;\n    var scale = exports.getScale(size, opts);\n    var symbolSize = Math.floor((size + opts.margin * 2) * scale);\n    var scaledMargin = opts.margin * scale;\n    var palette = [opts.color.light, opts.color.dark];\n    for (var i = 0; i < symbolSize; i++) {\n      for (var j = 0; j < symbolSize; j++) {\n        var posDst = (i * symbolSize + j) * 4;\n        var pxColor = opts.color.light;\n        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n          var iSrc = Math.floor((i - scaledMargin) / scale);\n          var jSrc = Math.floor((j - scaledMargin) / scale);\n          pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n        }\n        imgData[posDst++] = pxColor.r;\n        imgData[posDst++] = pxColor.g;\n        imgData[posDst++] = pxColor.b;\n        imgData[posDst] = pxColor.a;\n      }\n    }\n  };\n});\nvar canvas = createCommonjsModule(function (module, exports) {\n  function clearCanvas(ctx, canvas, size) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    if (!canvas.style) canvas.style = {};\n    canvas.height = size;\n    canvas.width = size;\n    canvas.style.height = size + 'px';\n    canvas.style.width = size + 'px';\n  }\n  function getCanvasElement() {\n    try {\n      return document.createElement('canvas');\n    } catch (e) {\n      throw new Error('You need to specify a canvas element');\n    }\n  }\n  exports.render = function render(qrData, canvas, options) {\n    var opts = options;\n    var canvasEl = canvas;\n    if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n    if (!canvas) {\n      canvasEl = getCanvasElement();\n    }\n    opts = utils$1.getOptions(opts);\n    var size = utils$1.getImageWidth(qrData.modules.size, opts);\n    var ctx = canvasEl.getContext('2d');\n    var image = ctx.createImageData(size, size);\n    utils$1.qrToImageData(image.data, qrData, opts);\n    clearCanvas(ctx, canvasEl, size);\n    ctx.putImageData(image, 0, 0);\n    return canvasEl;\n  };\n  exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n    var opts = options;\n    if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n    if (!opts) opts = {};\n    var canvasEl = exports.render(qrData, canvas, opts);\n    var type = opts.type || 'image/png';\n    var rendererOpts = opts.rendererOpts || {};\n    return canvasEl.toDataURL(type, rendererOpts.quality);\n  };\n});\nfunction getColorAttrib(color, attrib) {\n  var alpha = color.a / 255;\n  var str = attrib + '=\"' + color.hex + '\"';\n  return alpha < 1 ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"' : str;\n}\nfunction svgCmd(cmd, x, y) {\n  var str = cmd + x;\n  if (typeof y !== 'undefined') str += ' ' + y;\n  return str;\n}\nfunction qrToPath(data, size, margin) {\n  var path = '';\n  var moveBy = 0;\n  var newRow = false;\n  var lineLength = 0;\n  for (var i = 0; i < data.length; i++) {\n    var col = Math.floor(i % size);\n    var row = Math.floor(i / size);\n    if (!col && !newRow) newRow = true;\n    if (data[i]) {\n      lineLength++;\n      if (!(i > 0 && col > 0 && data[i - 1])) {\n        path += newRow ? svgCmd('M', col + margin, 0.5 + row + margin) : svgCmd('m', moveBy, 0);\n        moveBy = 0;\n        newRow = false;\n      }\n      if (!(col + 1 < size && data[i + 1])) {\n        path += svgCmd('h', lineLength);\n        lineLength = 0;\n      }\n    } else {\n      moveBy++;\n    }\n  }\n  return path;\n}\nvar render = function render(qrData, options, cb) {\n  var opts = utils$1.getOptions(options);\n  var size = qrData.modules.size;\n  var data = qrData.modules.data;\n  var qrcodesize = size + opts.margin * 2;\n  var bg = !opts.color.light.a ? '' : '<path ' + getColorAttrib(opts.color.light, 'fill') + ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>';\n  var path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') + ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n  var viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"';\n  var width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n  var svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n';\n  if (typeof cb === 'function') {\n    cb(null, svgTag);\n  }\n  return svgTag;\n};\nvar svgTag = {\n  render: render\n};\nfunction renderCanvas(renderFunc, canvas, text, opts, cb) {\n  var args = [].slice.call(arguments, 1);\n  var argsNum = args.length;\n  var isLastArgCb = typeof args[argsNum - 1] === 'function';\n  if (!isLastArgCb && !canPromise()) {\n    throw new Error('Callback required as last argument');\n  }\n  if (isLastArgCb) {\n    if (argsNum < 2) {\n      throw new Error('Too few arguments provided');\n    }\n    if (argsNum === 2) {\n      cb = text;\n      text = canvas;\n      canvas = opts = undefined;\n    } else if (argsNum === 3) {\n      if (canvas.getContext && typeof cb === 'undefined') {\n        cb = opts;\n        opts = undefined;\n      } else {\n        cb = opts;\n        opts = text;\n        text = canvas;\n        canvas = undefined;\n      }\n    }\n  } else {\n    if (argsNum < 1) {\n      throw new Error('Too few arguments provided');\n    }\n    if (argsNum === 1) {\n      text = canvas;\n      canvas = opts = undefined;\n    } else if (argsNum === 2 && !canvas.getContext) {\n      opts = text;\n      text = canvas;\n      canvas = undefined;\n    }\n    return new Promise(function (resolve, reject) {\n      try {\n        var data = qrcode.create(text, opts);\n        resolve(renderFunc(data, canvas, opts));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n  try {\n    var data = qrcode.create(text, opts);\n    cb(null, renderFunc(data, canvas, opts));\n  } catch (e) {\n    cb(e);\n  }\n}\nvar create$1 = qrcode.create;\nvar toCanvas = renderCanvas.bind(null, canvas.render);\nvar toDataURL = renderCanvas.bind(null, canvas.renderToDataURL);\n// only svg for now.\nvar toString_1 = renderCanvas.bind(null, function (data, _, opts) {\n  return svgTag.render(data, opts);\n});\nvar browser = {\n  create: create$1,\n  toCanvas: toCanvas,\n  toDataURL: toDataURL,\n  toString: toString_1\n};\nvar amplifyTotpSetupCss = \".totp-setup{text-align:center;margin-bottom:30px}.totp-setup img{height:128px;width:128px}\";\nvar logger = new Logger('TOTP');\nvar AmplifyTOTPSetup = /** @class */function () {\n  function class_1(hostRef) {\n    registerInstance(this, hostRef);\n    this.inputProps = {\n      autoFocus: true\n    };\n    /** Auth state change handler for this component */\n    this.handleAuthStateChange = dispatchAuthStateChangeEvent;\n    /** Used for header text in totp setup component */\n    this.headerText = Translations.TOTP_HEADER_TEXT;\n    /** Used for customizing the issuer string in the qr code image */\n    this.issuer = Translations.TOTP_ISSUER;\n    this.code = null;\n    this.setupMessage = null;\n    this.qrCodeInput = null;\n    this.loading = false;\n  }\n  class_1.prototype.componentWillLoad = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            /**\n             * We didn't use `@Watch` here because it doesn't fire when we go from require-new-password to totp-setup.\n             * That is because `Auth.completeNewPassword` only changes `user` in place and Watch doesn't detect changes\n             * unless we make a clone.\n             */\n            this.removeHubListener = onAuthUIStateChange(function (authState) {\n              if (authState === AuthState.TOTPSetup) _this.setup();\n            });\n            return [4 /*yield*/, this.setup()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  class_1.prototype.disconnectedCallback = function () {\n    this.removeHubListener && this.removeHubListener(); // stop listening to `onAuthUIStateChange`\n  };\n  class_1.prototype.buildOtpAuthPath = function (user, issuer, secretKey) {\n    return \"otpauth://totp/\" + issuer + \":\" + user.username + \"?secret=\" + secretKey + \"&issuer=\" + issuer;\n  };\n  class_1.prototype.onTOTPEvent = function (event, data, user) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('on totp event', event, data);\n            if (!(event === SETUP_TOTP && data === SUCCESS)) return [3 /*break*/, 2];\n            return [4 /*yield*/, checkContact(user, this.handleAuthStateChange)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  class_1.prototype.handleTotpInputChange = function (event) {\n    this.setupMessage = null;\n    this.qrCodeInput = event.target.value;\n  };\n  class_1.prototype.generateQRCode = function (codeFromTotp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, error_1;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 3]);\n            _a = this;\n            return [4 /*yield*/, browser.toDataURL(codeFromTotp)];\n          case 1:\n            _a.qrCodeImageSource = _b.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            error_1 = _b.sent();\n            dispatchToastHubEvent(error_1);\n            return [3 /*break*/, 3];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  class_1.prototype.setup = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedIssuer, secretKey, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // ensure setup is only run once after totp setup is available\n            if (!this.user || this.user.challengeName !== 'MFA_SETUP' || this.loading) return [2 /*return*/];\n            this.setupMessage = null;\n            encodedIssuer = encodeURI(I18n.get(this.issuer));\n            if (!Auth || typeof Auth.setupTOTP !== 'function') {\n              throw new Error(NO_AUTH_MODULE_FOUND);\n            }\n            this.loading = true;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3, 4, 5]);\n            return [4 /*yield*/, Auth.setupTOTP(this.user)];\n          case 2:\n            secretKey = _a.sent();\n            logger.debug('secret key', secretKey);\n            this.code = this.buildOtpAuthPath(this.user, encodedIssuer, secretKey);\n            this.generateQRCode(this.code);\n            return [3 /*break*/, 5];\n          case 3:\n            error_2 = _a.sent();\n            dispatchToastHubEvent(error_2);\n            logger.debug(I18n.get(Translations.TOTP_SETUP_FAILURE), error_2);\n            return [3 /*break*/, 5];\n          case 4:\n            this.loading = false;\n            return [7 /*endfinally*/];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  class_1.prototype.verifyTotpToken = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var user, error_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (event) {\n              event.preventDefault();\n            }\n            if (!this.qrCodeInput) {\n              logger.debug('No TOTP Code provided');\n              return [2 /*return*/];\n            }\n            user = this.user;\n            if (!Auth || typeof Auth.verifyTotpToken !== 'function' || typeof Auth.setPreferredMFA !== 'function') {\n              throw new Error(NO_AUTH_MODULE_FOUND);\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n            return [4 /*yield*/, Auth.verifyTotpToken(user, this.qrCodeInput)];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, Auth.setPreferredMFA(user, MfaOption.TOTP)];\n          case 3:\n            _a.sent();\n            this.setupMessage = I18n.get(Translations.TOTP_SUCCESS_MESSAGE);\n            logger.debug(I18n.get(Translations.TOTP_SUCCESS_MESSAGE));\n            return [4 /*yield*/, this.onTOTPEvent(SETUP_TOTP, SUCCESS, user)];\n          case 4:\n            _a.sent();\n            return [3 /*break*/, 6];\n          case 5:\n            error_3 = _a.sent();\n            this.setupMessage = I18n.get(Translations.TOTP_SETUP_FAILURE);\n            logger.error(error_3);\n            return [3 /*break*/, 6];\n          case 6:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  class_1.prototype.render = function () {\n    var _this = this;\n    return h(Host, null, h(\"amplify-form-section\", {\n      headerText: I18n.get(this.headerText),\n      submitButtonText: I18n.get(Translations.TOTP_SUBMIT_BUTTON_TEXT),\n      handleSubmit: function (event) {\n        return _this.verifyTotpToken(event);\n      },\n      loading: this.loading\n    }, h(\"div\", {\n      class: \"totp-setup\"\n    }, this.qrCodeImageSource && h(\"img\", {\n      src: this.qrCodeImageSource,\n      alt: I18n.get(Translations.QR_CODE_ALT)\n    }), h(\"amplify-form-field\", {\n      label: I18n.get(Translations.TOTP_LABEL),\n      inputProps: this.inputProps,\n      fieldId: \"totpCode\",\n      name: \"totpCode\",\n      handleInputChange: function (event) {\n        return _this.handleTotpInputChange(event);\n      }\n    }))));\n  };\n  return class_1;\n}();\nAmplifyTOTPSetup.style = amplifyTotpSetupCss;\nexport { AmplifyRadioButton as amplify_radio_button, AmplifyTOTPSetup as amplify_totp_setup };","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","r","registerInstance","h","H","Host","Logger","I18n","M","MfaOption","A","AuthState","Auth","T","Translations","S","SETUP_TOTP","i","SUCCESS","N","NO_AUTH_MODULE_FOUND","d","dispatchAuthStateChangeEvent","o","onAuthUIStateChange","a","dispatchToastHubEvent","c","checkContact","buffer","amplifyRadioButtonCss","AmplifyRadioButton","hostRef","placeholder","checked","disabled","prototype","render","class","Object","assign","type","name","onInput","handleInputChange","id","fieldId","inputProps","htmlFor","style","canPromise","toString","isarray","Array","isArray","arr","typedArraySupport","Uint8Array","__proto__","foo","Buffer","TYPED_ARRAY_SUPPORT","K_MAX_LENGTH","arg","offset","allocUnsafe","from","species","defineProperty","configurable","enumerable","writable","RangeError","isnan","val","createBuffer","that","buf","size","fromString","string","byteLength","actual","write","slice","fromArrayLike","array","fromArrayBuffer","byteOffset","undefined","fromObject","obj","isBuffer","len","copy","ArrayBuffer","data","utf8ToBytes","units","Infinity","codePoint","leadSurrogate","bytes","charCodeAt","Error","isView","blitBuffer","src","dst","utf8Write","isFinite","remaining","start","end","newBuf","subarray","sliceLen","target","targetStart","set","fill","code","concat","list","pos","_isBuffer","b","alloc","from_1","typedarrayBuffer","toSJISFunction","CODEWORDS_COUNT","getSymbolSize","version","getSymbolTotalCodewords","getBCHDigit","digit","setToSJISFunction","isKanjiModeEnabled","toSJIS","kanji","utils","createCommonjsModule","fn","basedir","module","path","exports","require","base","commonjsRequire","errorCorrectionLevel","L","bit","Q","lcStr","toLowerCase","isValid","level","defaultValue","BitBuffer","get","index","bufIndex","Math","floor","put","num","putBit","getLengthInBits","bitBuffer","BitMatrix","reservedBit","row","col","reserved","xor","isReserved","bitMatrix","alignmentPattern","getRowColCoords","posCount","intervals","ceil","positions","reverse","getPositions","coords","posLength","j","getSymbolSize$1","FINDER_PATTERN_SIZE","finderPattern","maskPattern","Patterns","PATTERN000","PATTERN001","PATTERN010","PATTERN011","PATTERN100","PATTERN101","PATTERN110","PATTERN111","PenaltyScores","N1","N2","N3","N4","mask","isNaN","parseInt","getPenaltyN1","points","sameCountCol","sameCountRow","lastCol","lastRow","getPenaltyN2","last","getPenaltyN3","bitsCol","bitsRow","getPenaltyN4","darkCount","modulesCount","k","abs","getMaskAt","applyMask","pattern","getBestMask","setupFormatFunc","numPatterns","keys","bestPattern","lowerPenalty","p","penalty","EC_BLOCKS_TABLE","EC_CODEWORDS_TABLE","getBlocksCount","errorCorrectionLevel$1","getTotalCodewordsCount","errorCorrectionCode","EXP_TABLE","LOG_TABLE","initTables","x","log","exp","mul","galoisField","polynomial","p1","p2","coeff","mod","divident","divisor","generateECPolynomial","degree","poly","Buffer$1","ReedSolomonEncoder","genPoly","initialize","encode","pad","paddedData","remainder","buff","reedSolomonEncoder","versionCheck","numeric","alphanumeric","replace","byte","KANJI","RegExp","BYTE_KANJI","BYTE","NUMERIC","ALPHANUMERIC","TEST_KANJI","TEST_NUMERIC","TEST_ALPHANUMERIC","testKanji","str","test","testNumeric","testAlphanumeric","regex","mode","ccBits","MIXED","getCharCountIndicator","getBestModeForData","dataStr","G18","G18_BCH","getBestVersionForDataLength","currentVersion","getCapacity","getReservedBitsCount","mode$1","getTotalBitsFromDataArray","segments","totalBits","forEach","reservedBits","getBitsLength","getBestVersionForMixedData","totalCodewords","ecTotalCodewords","dataTotalCodewordsBits","usableBits","getBestVersionForData","seg","ecl","getLength","getEncodedBits","G15","G15_MASK","G15_BCH","formatInfo","NumericData","group","substr","remainingNum","numericData","ALPHA_NUM_CHARS","AlphanumericData","indexOf","alphanumericData","ByteData","l","byteData","KanjiData","kanjiData","dijkstra_1","dijkstra","single_source_shortest_paths","graph","s","predecessors","costs","open","PriorityQueue","make","closest","u","cost_of_s_to_u","adjacent_nodes","cost_of_e","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","first_visit","empty","cost","hasOwnProperty","msg","join","extract_shortest_path_from_predecessor_list","nodes","find_path","opts","key","queue","sorter","default_sorter","item","sort","shift","getStringByteLength","unescape","encodeURIComponent","getSegments","exec","getSegmentsFromString","numSegs","alphaNumSegs","byteSegs","kanjiSegs","segs","s1","s2","map","getSegmentBitsLength","mergeSegments","reduce","acc","curr","prevSeg","buildNodes","buildGraph","table","prevNodeIds","nodeGroup","currentNodeIds","node","lastCount","prevNodeId","buildSingleSegment","modesHint","bestMode","fromArray","optimizedSegs","rawSplit","setupFinderPattern","matrix","setupTimingPattern","setupAlignmentPattern","setupVersionInfo","version$1","bits","setupFormatInfo","setupData","inc","bitIndex","byteIndex","dark","createData","remainingByte","createCodewords","dataTotalCodewords","ecTotalBlocks","blocksInGroup2","blocksInGroup1","totalCodewordsInGroup1","dataCodewordsInGroup1","dataCodewordsInGroup2","ecCount","rs","dcData","ecData","maxDataSize","dataSize","max","createSymbol","maskPattern$1","segments$1","estimatedVersion","rawSegments","bestVersion","dataBits","moduleCount","modules","bind","create","options","toSJISFunc","qrcode","utils$1","hex2rgba","hex","hexCode","split","hexValue","getOptions","color","margin","width","scale","light","rendererOpts","getScale","qrSize","getImageWidth","qrToImageData","imgData","qr","symbolSize","scaledMargin","palette","posDst","pxColor","iSrc","jSrc","canvas","clearCanvas","ctx","clearRect","height","getCanvasElement","document","createElement","qrData","canvasEl","getContext","image","createImageData","putImageData","renderToDataURL","toDataURL","quality","getColorAttrib","attrib","alpha","toFixed","svgCmd","cmd","qrToPath","moveBy","newRow","lineLength","cb","qrcodesize","bg","viewBox","svgTag","renderCanvas","renderFunc","text","args","arguments","argsNum","isLastArgCb","create$1","toCanvas","toString_1","browser","amplifyTotpSetupCss","logger","AmplifyTOTPSetup","class_1","autoFocus","handleAuthStateChange","headerText","TOTP_HEADER_TEXT","issuer","TOTP_ISSUER","setupMessage","qrCodeInput","loading","componentWillLoad","_this","_a","removeHubListener","authState","TOTPSetup","setup","disconnectedCallback","buildOtpAuthPath","user","secretKey","username","onTOTPEvent","event","debug","handleTotpInputChange","generateQRCode","codeFromTotp","error_1","_b","qrCodeImageSource","encodedIssuer","error_2","challengeName","encodeURI","setupTOTP","TOTP_SETUP_FAILURE","verifyTotpToken","error_3","preventDefault","setPreferredMFA","TOTP","TOTP_SUCCESS_MESSAGE","error","submitButtonText","TOTP_SUBMIT_BUTTON_TEXT","handleSubmit","alt","QR_CODE_ALT","TOTP_LABEL","amplify_radio_button","amplify_totp_setup"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/@aws-amplify/ui-components/dist/esm-es5/amplify-radio-button_2.entry.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { r as registerInstance, h, H as Host } from './index-3fb5c139.js';\nimport { Logger, I18n } from '@aws-amplify/core';\nimport { M as MfaOption, A as AuthState } from './auth-types-78df304e.js';\nimport { Auth } from '@aws-amplify/auth';\nimport { T as Translations } from './Translations-c833f663.js';\nimport { S as SETUP_TOTP, i as SUCCESS, N as NO_AUTH_MODULE_FOUND } from './constants-d1abe7de.js';\nimport { d as dispatchAuthStateChangeEvent, o as onAuthUIStateChange, a as dispatchToastHubEvent } from './helpers-4f61e5ff.js';\nimport { c as checkContact } from './auth-helpers-bd096ca7.js';\nimport buffer from 'buffer';\nvar amplifyRadioButtonCss = \":host{--font-family:var(--amplify-font-family)}.radio-button{display:block;width:100%;padding:16px;font-size:var(--amplify-text-sm);font-family:var(--font-family)}.radio-button input{margin-right:12px}\";\nvar AmplifyRadioButton = /** @class */ (function () {\n    function AmplifyRadioButton(hostRef) {\n        registerInstance(this, hostRef);\n        /** (Optional) The placeholder for the input element.  Using hints is recommended, but placeholders can also be useful to convey information to users. */\n        this.placeholder = '';\n        /** If `true`, the radio button is selected. */\n        this.checked = false;\n        /** If `true`, the checkbox is disabled */\n        this.disabled = false;\n    }\n    AmplifyRadioButton.prototype.render = function () {\n        return (h(\"span\", { class: \"radio-button\" }, h(\"input\", Object.assign({ type: \"radio\", name: this.name, value: this.value, onInput: this.handleInputChange, placeholder: this.placeholder, id: this.fieldId, checked: this.checked, disabled: this.disabled }, this.inputProps)), h(\"amplify-label\", { htmlFor: this.fieldId }, this.label)));\n    };\n    return AmplifyRadioButton;\n}());\nAmplifyRadioButton.style = amplifyRadioButtonCss;\n// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\nvar canPromise = function () {\n    return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;\n};\nvar toString = {}.toString;\nvar isarray = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n};\nfunction typedArraySupport() {\n    // Can typed array instances be augmented?\n    try {\n        var arr = new Uint8Array(1);\n        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } };\n        return arr.foo() === 42;\n    }\n    catch (e) {\n        return false;\n    }\n}\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\nvar K_MAX_LENGTH = Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff;\nfunction Buffer(arg, offset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, offset, length);\n    }\n    if (typeof arg === 'number') {\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, offset, length);\n}\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    if (typeof Symbol !== 'undefined' && Symbol.species &&\n        Buffer[Symbol.species] === Buffer) {\n        Object.defineProperty(Buffer, Symbol.species, {\n            value: null,\n            configurable: true,\n            enumerable: false,\n            writable: false\n        });\n    }\n}\nfunction checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= K_MAX_LENGTH) {\n        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n    }\n    return length | 0;\n}\nfunction isnan(val) {\n    return val !== val; // eslint-disable-line no-self-compare\n}\nfunction createBuffer(that, length) {\n    var buf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        buf = new Uint8Array(length);\n        buf.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        buf = that;\n        if (buf === null) {\n            buf = new Buffer(length);\n        }\n        buf.length = length;\n    }\n    return buf;\n}\nfunction allocUnsafe(that, size) {\n    var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            buf[i] = 0;\n        }\n    }\n    return buf;\n}\nfunction fromString(that, string) {\n    var length = byteLength(string) | 0;\n    var buf = createBuffer(that, length);\n    var actual = buf.write(string);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        buf = buf.slice(0, actual);\n    }\n    return buf;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    var buf = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n    }\n    return buf;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\\'length\\' is out of bounds');\n    }\n    var buf;\n    if (byteOffset === undefined && length === undefined) {\n        buf = new Uint8Array(array);\n    }\n    else if (length === undefined) {\n        buf = new Uint8Array(array, byteOffset);\n    }\n    else {\n        buf = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        buf.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        buf = fromArrayLike(that, buf);\n    }\n    return buf;\n}\nfunction fromObject(that, obj) {\n    if (Buffer.isBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        var buf = createBuffer(that, len);\n        if (buf.length === 0) {\n            return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj) {\n        if ((typeof ArrayBuffer !== 'undefined' &&\n            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1)\n                    bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        }\n        else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1)\n                bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0)\n                break;\n            bytes.push(codePoint);\n        }\n        else if (codePoint < 0x800) {\n            if ((units -= 2) < 0)\n                break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0)\n                break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0)\n                break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else {\n            throw new Error('Invalid code point');\n        }\n    }\n    return bytes;\n}\nfunction byteLength(string) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== 'string') {\n        string = '' + string;\n    }\n    var len = string.length;\n    if (len === 0)\n        return 0;\n    return utf8ToBytes(string).length;\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n        if ((i + offset >= dst.length) || (i >= src.length))\n            break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction from(that, value, offset, length) {\n    if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, offset, length);\n    }\n    if (typeof value === 'string') {\n        return fromString(that, value);\n    }\n    return fromObject(that, value);\n}\nBuffer.prototype.write = function write(string, offset, length) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, encoding)\n    }\n    else if (length === undefined && typeof offset === 'string') {\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, offset[, length])\n    }\n    else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n        }\n        else {\n            length = undefined;\n        }\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining)\n        length = remaining;\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n        throw new RangeError('Attempt to write outside buffer bounds');\n    }\n    return utf8Write(this, string, offset, length);\n};\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0)\n            start = 0;\n    }\n    else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0)\n            end = 0;\n    }\n    else if (end > len) {\n        end = len;\n    }\n    if (end < start)\n        end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        // Return an augmented `Uint8Array` instance\n        newBuf.__proto__ = Buffer.prototype;\n    }\n    else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start)\n        start = 0;\n    if (!end && end !== 0)\n        end = this.length;\n    if (targetStart >= target.length)\n        targetStart = target.length;\n    if (!targetStart)\n        targetStart = 0;\n    if (end > 0 && end < start)\n        end = start;\n    // Copy 0 bytes; we're done\n    if (end === start)\n        return 0;\n    if (target.length === 0 || this.length === 0)\n        return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds');\n    }\n    if (start < 0 || start >= this.length)\n        throw new RangeError('sourceStart out of bounds');\n    if (end < 0)\n        throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length)\n        end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\nBuffer.prototype.fill = function fill(val, start, end) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            start = 0;\n            end = this.length;\n        }\n        else if (typeof end === 'string') {\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n    }\n    else if (typeof val === 'number') {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index');\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val)\n        val = 0;\n    var i;\n    if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n            this[i] = val;\n        }\n    }\n    else {\n        var bytes = Buffer.isBuffer(val)\n            ? val\n            : new Buffer(val);\n        var len = bytes.length;\n        for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\nBuffer.concat = function concat(list, length) {\n    if (!isarray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return createBuffer(null, 0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n        }\n    }\n    var buffer = allocUnsafe(null, length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nBuffer.byteLength = byteLength;\nBuffer.prototype._isBuffer = true;\nBuffer.isBuffer = function isBuffer(b) {\n    return !!(b != null && b._isBuffer);\n};\nvar alloc = function (size) {\n    var buffer = new Buffer(size);\n    buffer.fill(0);\n    return buffer;\n};\nvar from_1 = function (data) {\n    return new Buffer(data);\n};\nvar typedarrayBuffer = {\n    alloc: alloc,\n    from: from_1\n};\nvar toSJISFunction;\nvar CODEWORDS_COUNT = [\n    0,\n    26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n    404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n    2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n];\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nvar getSymbolSize = function getSymbolSize(version) {\n    if (!version)\n        throw new Error('\"version\" cannot be null or undefined');\n    if (version < 1 || version > 40)\n        throw new Error('\"version\" should be in range from 1 to 40');\n    return version * 4 + 17;\n};\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nvar getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n    return CODEWORDS_COUNT[version];\n};\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nvar getBCHDigit = function (data) {\n    var digit = 0;\n    while (data !== 0) {\n        digit++;\n        data >>>= 1;\n    }\n    return digit;\n};\nvar setToSJISFunction = function setToSJISFunction(f) {\n    if (typeof f !== 'function') {\n        throw new Error('\"toSJISFunc\" is not a valid function.');\n    }\n    toSJISFunction = f;\n};\nvar isKanjiModeEnabled = function () {\n    return typeof toSJISFunction !== 'undefined';\n};\nvar toSJIS = function toSJIS(kanji) {\n    return toSJISFunction(kanji);\n};\nvar utils = {\n    getSymbolSize: getSymbolSize,\n    getSymbolTotalCodewords: getSymbolTotalCodewords,\n    getBCHDigit: getBCHDigit,\n    setToSJISFunction: setToSJISFunction,\n    isKanjiModeEnabled: isKanjiModeEnabled,\n    toSJIS: toSJIS\n};\nfunction createCommonjsModule(fn, basedir, module) {\n    return module = {\n        path: basedir,\n        exports: {},\n        require: function (path, base) {\n            return commonjsRequire();\n        }\n    }, fn(module, module.exports), module.exports;\n}\nfunction commonjsRequire() {\n    throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\nvar errorCorrectionLevel = createCommonjsModule(function (module, exports) {\n    exports.L = { bit: 1 };\n    exports.M = { bit: 0 };\n    exports.Q = { bit: 3 };\n    exports.H = { bit: 2 };\n    function fromString(string) {\n        if (typeof string !== 'string') {\n            throw new Error('Param is not a string');\n        }\n        var lcStr = string.toLowerCase();\n        switch (lcStr) {\n            case 'l':\n            case 'low':\n                return exports.L;\n            case 'm':\n            case 'medium':\n                return exports.M;\n            case 'q':\n            case 'quartile':\n                return exports.Q;\n            case 'h':\n            case 'high':\n                return exports.H;\n            default:\n                throw new Error('Unknown EC Level: ' + string);\n        }\n    }\n    exports.isValid = function isValid(level) {\n        return level && typeof level.bit !== 'undefined' &&\n            level.bit >= 0 && level.bit < 4;\n    };\n    exports.from = function from(value, defaultValue) {\n        if (exports.isValid(value)) {\n            return value;\n        }\n        try {\n            return fromString(value);\n        }\n        catch (e) {\n            return defaultValue;\n        }\n    };\n});\nfunction BitBuffer() {\n    this.buffer = [];\n    this.length = 0;\n}\nBitBuffer.prototype = {\n    get: function (index) {\n        var bufIndex = Math.floor(index / 8);\n        return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;\n    },\n    put: function (num, length) {\n        for (var i = 0; i < length; i++) {\n            this.putBit(((num >>> (length - i - 1)) & 1) === 1);\n        }\n    },\n    getLengthInBits: function () {\n        return this.length;\n    },\n    putBit: function (bit) {\n        var bufIndex = Math.floor(this.length / 8);\n        if (this.buffer.length <= bufIndex) {\n            this.buffer.push(0);\n        }\n        if (bit) {\n            this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));\n        }\n        this.length++;\n    }\n};\nvar bitBuffer = BitBuffer;\n/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix(size) {\n    if (!size || size < 1) {\n        throw new Error('BitMatrix size must be defined and greater than 0');\n    }\n    this.size = size;\n    this.data = typedarrayBuffer.alloc(size * size);\n    this.reservedBit = typedarrayBuffer.alloc(size * size);\n}\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n    var index = row * this.size + col;\n    this.data[index] = value;\n    if (reserved)\n        this.reservedBit[index] = true;\n};\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n    return this.data[row * this.size + col];\n};\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n    this.data[row * this.size + col] ^= value;\n};\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n    return this.reservedBit[row * this.size + col];\n};\nvar bitMatrix = BitMatrix;\nvar alignmentPattern = createCommonjsModule(function (module, exports) {\n    /**\n     * Alignment pattern are fixed reference pattern in defined positions\n     * in a matrix symbology, which enables the decode software to re-synchronise\n     * the coordinate mapping of the image modules in the event of moderate amounts\n     * of distortion of the image.\n     *\n     * Alignment patterns are present only in QR Code symbols of version 2 or larger\n     * and their number depends on the symbol version.\n     */\n    var getSymbolSize = utils.getSymbolSize;\n    /**\n     * Calculate the row/column coordinates of the center module of each alignment pattern\n     * for the specified QR Code version.\n     *\n     * The alignment patterns are positioned symmetrically on either side of the diagonal\n     * running from the top left corner of the symbol to the bottom right corner.\n     *\n     * Since positions are simmetrical only half of the coordinates are returned.\n     * Each item of the array will represent in turn the x and y coordinate.\n     * @see {@link getPositions}\n     *\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of coordinate\n     */\n    exports.getRowColCoords = function getRowColCoords(version) {\n        if (version === 1)\n            return [];\n        var posCount = Math.floor(version / 7) + 2;\n        var size = getSymbolSize(version);\n        var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n        var positions = [size - 7]; // Last coord is always (size - 7)\n        for (var i = 1; i < posCount - 1; i++) {\n            positions[i] = positions[i - 1] - intervals;\n        }\n        positions.push(6); // First coord is always 6\n        return positions.reverse();\n    };\n    /**\n     * Returns an array containing the positions of each alignment pattern.\n     * Each array's element represent the center point of the pattern as (x, y) coordinates\n     *\n     * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n     * and filtering out the items that overlaps with finder pattern\n     *\n     * @example\n     * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n     * The alignment patterns, therefore, are to be centered on (row, column)\n     * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n     * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n     * and are not therefore used for alignment patterns.\n     *\n     * var pos = getPositions(7)\n     * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n     *\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of coordinates\n     */\n    exports.getPositions = function getPositions(version) {\n        var coords = [];\n        var pos = exports.getRowColCoords(version);\n        var posLength = pos.length;\n        for (var i = 0; i < posLength; i++) {\n            for (var j = 0; j < posLength; j++) {\n                // Skip if position is occupied by finder patterns\n                if ((i === 0 && j === 0) || // top-left\n                    (i === 0 && j === posLength - 1) || // bottom-left\n                    (i === posLength - 1 && j === 0)) { // top-right\n                    continue;\n                }\n                coords.push([pos[i], pos[j]]);\n            }\n        }\n        return coords;\n    };\n});\nvar getSymbolSize$1 = utils.getSymbolSize;\nvar FINDER_PATTERN_SIZE = 7;\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nvar getPositions = function getPositions(version) {\n    var size = getSymbolSize$1(version);\n    return [\n        // top-left\n        [0, 0],\n        // top-right\n        [size - FINDER_PATTERN_SIZE, 0],\n        // bottom-left\n        [0, size - FINDER_PATTERN_SIZE]\n    ];\n};\nvar finderPattern = {\n    getPositions: getPositions\n};\nvar maskPattern = createCommonjsModule(function (module, exports) {\n    /**\n     * Data mask pattern reference\n     * @type {Object}\n     */\n    exports.Patterns = {\n        PATTERN000: 0,\n        PATTERN001: 1,\n        PATTERN010: 2,\n        PATTERN011: 3,\n        PATTERN100: 4,\n        PATTERN101: 5,\n        PATTERN110: 6,\n        PATTERN111: 7\n    };\n    /**\n     * Weighted penalty scores for the undesirable features\n     * @type {Object}\n     */\n    var PenaltyScores = {\n        N1: 3,\n        N2: 3,\n        N3: 40,\n        N4: 10\n    };\n    /**\n     * Check if mask pattern value is valid\n     *\n     * @param  {Number}  mask    Mask pattern\n     * @return {Boolean}         true if valid, false otherwise\n     */\n    exports.isValid = function isValid(mask) {\n        return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;\n    };\n    /**\n     * Returns mask pattern from a value.\n     * If value is not valid, returns undefined\n     *\n     * @param  {Number|String} value        Mask pattern value\n     * @return {Number}                     Valid mask pattern or undefined\n     */\n    exports.from = function from(value) {\n        return exports.isValid(value) ? parseInt(value, 10) : undefined;\n    };\n    /**\n    * Find adjacent modules in row/column with the same color\n    * and assign a penalty value.\n    *\n    * Points: N1 + i\n    * i is the amount by which the number of adjacent modules of the same color exceeds 5\n    */\n    exports.getPenaltyN1 = function getPenaltyN1(data) {\n        var size = data.size;\n        var points = 0;\n        var sameCountCol = 0;\n        var sameCountRow = 0;\n        var lastCol = null;\n        var lastRow = null;\n        for (var row = 0; row < size; row++) {\n            sameCountCol = sameCountRow = 0;\n            lastCol = lastRow = null;\n            for (var col = 0; col < size; col++) {\n                var module = data.get(row, col);\n                if (module === lastCol) {\n                    sameCountCol++;\n                }\n                else {\n                    if (sameCountCol >= 5)\n                        points += PenaltyScores.N1 + (sameCountCol - 5);\n                    lastCol = module;\n                    sameCountCol = 1;\n                }\n                module = data.get(col, row);\n                if (module === lastRow) {\n                    sameCountRow++;\n                }\n                else {\n                    if (sameCountRow >= 5)\n                        points += PenaltyScores.N1 + (sameCountRow - 5);\n                    lastRow = module;\n                    sameCountRow = 1;\n                }\n            }\n            if (sameCountCol >= 5)\n                points += PenaltyScores.N1 + (sameCountCol - 5);\n            if (sameCountRow >= 5)\n                points += PenaltyScores.N1 + (sameCountRow - 5);\n        }\n        return points;\n    };\n    /**\n     * Find 2x2 blocks with the same color and assign a penalty value\n     *\n     * Points: N2 * (m - 1) * (n - 1)\n     */\n    exports.getPenaltyN2 = function getPenaltyN2(data) {\n        var size = data.size;\n        var points = 0;\n        for (var row = 0; row < size - 1; row++) {\n            for (var col = 0; col < size - 1; col++) {\n                var last = data.get(row, col) +\n                    data.get(row, col + 1) +\n                    data.get(row + 1, col) +\n                    data.get(row + 1, col + 1);\n                if (last === 4 || last === 0)\n                    points++;\n            }\n        }\n        return points * PenaltyScores.N2;\n    };\n    /**\n     * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n     * preceded or followed by light area 4 modules wide\n     *\n     * Points: N3 * number of pattern found\n     */\n    exports.getPenaltyN3 = function getPenaltyN3(data) {\n        var size = data.size;\n        var points = 0;\n        var bitsCol = 0;\n        var bitsRow = 0;\n        for (var row = 0; row < size; row++) {\n            bitsCol = bitsRow = 0;\n            for (var col = 0; col < size; col++) {\n                bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);\n                if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D))\n                    points++;\n                bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);\n                if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D))\n                    points++;\n            }\n        }\n        return points * PenaltyScores.N3;\n    };\n    /**\n     * Calculate proportion of dark modules in entire symbol\n     *\n     * Points: N4 * k\n     *\n     * k is the rating of the deviation of the proportion of dark modules\n     * in the symbol from 50% in steps of 5%\n     */\n    exports.getPenaltyN4 = function getPenaltyN4(data) {\n        var darkCount = 0;\n        var modulesCount = data.data.length;\n        for (var i = 0; i < modulesCount; i++)\n            darkCount += data.data[i];\n        var k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);\n        return k * PenaltyScores.N4;\n    };\n    /**\n     * Return mask value at given position\n     *\n     * @param  {Number} maskPattern Pattern reference value\n     * @param  {Number} i           Row\n     * @param  {Number} j           Column\n     * @return {Boolean}            Mask value\n     */\n    function getMaskAt(maskPattern, i, j) {\n        switch (maskPattern) {\n            case exports.Patterns.PATTERN000: return (i + j) % 2 === 0;\n            case exports.Patterns.PATTERN001: return i % 2 === 0;\n            case exports.Patterns.PATTERN010: return j % 3 === 0;\n            case exports.Patterns.PATTERN011: return (i + j) % 3 === 0;\n            case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n            case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0;\n            case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0;\n            case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0;\n            default: throw new Error('bad maskPattern:' + maskPattern);\n        }\n    }\n    /**\n     * Apply a mask pattern to a BitMatrix\n     *\n     * @param  {Number}    pattern Pattern reference number\n     * @param  {BitMatrix} data    BitMatrix data\n     */\n    exports.applyMask = function applyMask(pattern, data) {\n        var size = data.size;\n        for (var col = 0; col < size; col++) {\n            for (var row = 0; row < size; row++) {\n                if (data.isReserved(row, col))\n                    continue;\n                data.xor(row, col, getMaskAt(pattern, row, col));\n            }\n        }\n    };\n    /**\n     * Returns the best mask pattern for data\n     *\n     * @param  {BitMatrix} data\n     * @return {Number} Mask pattern reference number\n     */\n    exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n        var numPatterns = Object.keys(exports.Patterns).length;\n        var bestPattern = 0;\n        var lowerPenalty = Infinity;\n        for (var p = 0; p < numPatterns; p++) {\n            setupFormatFunc(p);\n            exports.applyMask(p, data);\n            // Calculate penalty\n            var penalty = exports.getPenaltyN1(data) +\n                exports.getPenaltyN2(data) +\n                exports.getPenaltyN3(data) +\n                exports.getPenaltyN4(data);\n            // Undo previously applied mask\n            exports.applyMask(p, data);\n            if (penalty < lowerPenalty) {\n                lowerPenalty = penalty;\n                bestPattern = p;\n            }\n        }\n        return bestPattern;\n    };\n});\nvar EC_BLOCKS_TABLE = [\n    // L  M  Q  H\n    1, 1, 1, 1,\n    1, 1, 1, 1,\n    1, 1, 2, 2,\n    1, 2, 2, 4,\n    1, 2, 4, 4,\n    2, 4, 4, 4,\n    2, 4, 6, 5,\n    2, 4, 6, 6,\n    2, 5, 8, 8,\n    4, 5, 8, 8,\n    4, 5, 8, 11,\n    4, 8, 10, 11,\n    4, 9, 12, 16,\n    4, 9, 16, 16,\n    6, 10, 12, 18,\n    6, 10, 17, 16,\n    6, 11, 16, 19,\n    6, 13, 18, 21,\n    7, 14, 21, 25,\n    8, 16, 20, 25,\n    8, 17, 23, 25,\n    9, 17, 23, 34,\n    9, 18, 25, 30,\n    10, 20, 27, 32,\n    12, 21, 29, 35,\n    12, 23, 34, 37,\n    12, 25, 34, 40,\n    13, 26, 35, 42,\n    14, 28, 38, 45,\n    15, 29, 40, 48,\n    16, 31, 43, 51,\n    17, 33, 45, 54,\n    18, 35, 48, 57,\n    19, 37, 51, 60,\n    19, 38, 53, 63,\n    20, 40, 56, 66,\n    21, 43, 59, 70,\n    22, 45, 62, 74,\n    24, 47, 65, 77,\n    25, 49, 68, 81\n];\nvar EC_CODEWORDS_TABLE = [\n    // L  M  Q  H\n    7, 10, 13, 17,\n    10, 16, 22, 28,\n    15, 26, 36, 44,\n    20, 36, 52, 64,\n    26, 48, 72, 88,\n    36, 64, 96, 112,\n    40, 72, 108, 130,\n    48, 88, 132, 156,\n    60, 110, 160, 192,\n    72, 130, 192, 224,\n    80, 150, 224, 264,\n    96, 176, 260, 308,\n    104, 198, 288, 352,\n    120, 216, 320, 384,\n    132, 240, 360, 432,\n    144, 280, 408, 480,\n    168, 308, 448, 532,\n    180, 338, 504, 588,\n    196, 364, 546, 650,\n    224, 416, 600, 700,\n    224, 442, 644, 750,\n    252, 476, 690, 816,\n    270, 504, 750, 900,\n    300, 560, 810, 960,\n    312, 588, 870, 1050,\n    336, 644, 952, 1110,\n    360, 700, 1020, 1200,\n    390, 728, 1050, 1260,\n    420, 784, 1140, 1350,\n    450, 812, 1200, 1440,\n    480, 868, 1290, 1530,\n    510, 924, 1350, 1620,\n    540, 980, 1440, 1710,\n    570, 1036, 1530, 1800,\n    570, 1064, 1590, 1890,\n    600, 1120, 1680, 1980,\n    630, 1204, 1770, 2100,\n    660, 1260, 1860, 2220,\n    720, 1316, 1950, 2310,\n    750, 1372, 2040, 2430\n];\n/**\n * Returns the number of error correction block that the QR Code should contain\n * for the specified version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction blocks\n */\nvar getBlocksCount = function getBlocksCount(version, errorCorrectionLevel$1) {\n    switch (errorCorrectionLevel$1) {\n        case errorCorrectionLevel.L:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n        case errorCorrectionLevel.M:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n        case errorCorrectionLevel.Q:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n        case errorCorrectionLevel.H:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n        default:\n            return undefined;\n    }\n};\n/**\n * Returns the number of error correction codewords to use for the specified\n * version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction codewords\n */\nvar getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel$1) {\n    switch (errorCorrectionLevel$1) {\n        case errorCorrectionLevel.L:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n        case errorCorrectionLevel.M:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n        case errorCorrectionLevel.Q:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n        case errorCorrectionLevel.H:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n        default:\n            return undefined;\n    }\n};\nvar errorCorrectionCode = {\n    getBlocksCount: getBlocksCount,\n    getTotalCodewordsCount: getTotalCodewordsCount\n};\nvar EXP_TABLE = typedarrayBuffer.alloc(512);\nvar LOG_TABLE = typedarrayBuffer.alloc(256);\n(function initTables() {\n    var x = 1;\n    for (var i = 0; i < 255; i++) {\n        EXP_TABLE[i] = x;\n        LOG_TABLE[x] = i;\n        x <<= 1; // multiply by 2\n        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n        // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n        if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n            x ^= 0x11D;\n        }\n    }\n    // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n    // stay inside the bounds (because we will mainly use this table for the multiplication of\n    // two GF numbers, no more).\n    // @see {@link mul}\n    for (i = 255; i < 512; i++) {\n        EXP_TABLE[i] = EXP_TABLE[i - 255];\n    }\n}());\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar log = function log(n) {\n    if (n < 1)\n        throw new Error('log(' + n + ')');\n    return LOG_TABLE[n];\n};\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar exp = function exp(n) {\n    return EXP_TABLE[n];\n};\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nvar mul = function mul(x, y) {\n    if (x === 0 || y === 0)\n        return 0;\n    // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n    // @see {@link initTables}\n    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n};\nvar galoisField = {\n    log: log,\n    exp: exp,\n    mul: mul\n};\nvar polynomial = createCommonjsModule(function (module, exports) {\n    /**\n     * Multiplies two polynomials inside Galois Field\n     *\n     * @param  {Buffer} p1 Polynomial\n     * @param  {Buffer} p2 Polynomial\n     * @return {Buffer}    Product of p1 and p2\n     */\n    exports.mul = function mul(p1, p2) {\n        var coeff = typedarrayBuffer.alloc(p1.length + p2.length - 1);\n        for (var i = 0; i < p1.length; i++) {\n            for (var j = 0; j < p2.length; j++) {\n                coeff[i + j] ^= galoisField.mul(p1[i], p2[j]);\n            }\n        }\n        return coeff;\n    };\n    /**\n     * Calculate the remainder of polynomials division\n     *\n     * @param  {Buffer} divident Polynomial\n     * @param  {Buffer} divisor  Polynomial\n     * @return {Buffer}          Remainder\n     */\n    exports.mod = function mod(divident, divisor) {\n        var result = typedarrayBuffer.from(divident);\n        while ((result.length - divisor.length) >= 0) {\n            var coeff = result[0];\n            for (var i = 0; i < divisor.length; i++) {\n                result[i] ^= galoisField.mul(divisor[i], coeff);\n            }\n            // remove all zeros from buffer head\n            var offset = 0;\n            while (offset < result.length && result[offset] === 0)\n                offset++;\n            result = result.slice(offset);\n        }\n        return result;\n    };\n    /**\n     * Generate an irreducible generator polynomial of specified degree\n     * (used by Reed-Solomon encoder)\n     *\n     * @param  {Number} degree Degree of the generator polynomial\n     * @return {Buffer}        Buffer containing polynomial coefficients\n     */\n    exports.generateECPolynomial = function generateECPolynomial(degree) {\n        var poly = typedarrayBuffer.from([1]);\n        for (var i = 0; i < degree; i++) {\n            poly = exports.mul(poly, [1, galoisField.exp(i)]);\n        }\n        return poly;\n    };\n});\nvar Buffer$1 = buffer.Buffer;\nfunction ReedSolomonEncoder(degree) {\n    this.genPoly = undefined;\n    this.degree = degree;\n    if (this.degree)\n        this.initialize(this.degree);\n}\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n    // create an irreducible generator polynomial\n    this.degree = degree;\n    this.genPoly = polynomial.generateECPolynomial(this.degree);\n};\n/**\n * Encodes a chunk of data\n *\n * @param  {Buffer} data Buffer containing input data\n * @return {Buffer}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode(data) {\n    if (!this.genPoly) {\n        throw new Error('Encoder not initialized');\n    }\n    // Calculate EC for this data block\n    // extends data size to data+genPoly size\n    var pad = typedarrayBuffer.alloc(this.degree);\n    var paddedData = Buffer$1.concat([data, pad], data.length + this.degree);\n    // The error correction codewords are the remainder after dividing the data codewords\n    // by a generator polynomial\n    var remainder = polynomial.mod(paddedData, this.genPoly);\n    // return EC data blocks (last n byte, where n is the degree of genPoly)\n    // If coefficients number in remainder are less than genPoly degree,\n    // pad with 0s to the left to reach the needed number of coefficients\n    var start = this.degree - remainder.length;\n    if (start > 0) {\n        var buff = typedarrayBuffer.alloc(this.degree);\n        remainder.copy(buff, start);\n        return buff;\n    }\n    return remainder;\n};\nvar reedSolomonEncoder = ReedSolomonEncoder;\n/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nvar isValid = function isValid(version) {\n    return !isNaN(version) && version >= 1 && version <= 40;\n};\nvar versionCheck = {\n    isValid: isValid\n};\nvar numeric = '[0-9]+';\nvar alphanumeric = '[A-Z $%*+\\\\-./:]+';\nvar kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n    '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n    '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n    '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';\nkanji = kanji.replace(/u/g, '\\\\u');\nvar byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+';\nvar KANJI = new RegExp(kanji, 'g');\nvar BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g');\nvar BYTE = new RegExp(byte, 'g');\nvar NUMERIC = new RegExp(numeric, 'g');\nvar ALPHANUMERIC = new RegExp(alphanumeric, 'g');\nvar TEST_KANJI = new RegExp('^' + kanji + '$');\nvar TEST_NUMERIC = new RegExp('^' + numeric + '$');\nvar TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$');\nvar testKanji = function testKanji(str) {\n    return TEST_KANJI.test(str);\n};\nvar testNumeric = function testNumeric(str) {\n    return TEST_NUMERIC.test(str);\n};\nvar testAlphanumeric = function testAlphanumeric(str) {\n    return TEST_ALPHANUMERIC.test(str);\n};\nvar regex = {\n    KANJI: KANJI,\n    BYTE_KANJI: BYTE_KANJI,\n    BYTE: BYTE,\n    NUMERIC: NUMERIC,\n    ALPHANUMERIC: ALPHANUMERIC,\n    testKanji: testKanji,\n    testNumeric: testNumeric,\n    testAlphanumeric: testAlphanumeric\n};\nvar mode = createCommonjsModule(function (module, exports) {\n    /**\n     * Numeric mode encodes data from the decimal digit set (0 - 9)\n     * (byte values 30HEX to 39HEX).\n     * Normally, 3 data characters are represented by 10 bits.\n     *\n     * @type {Object}\n     */\n    exports.NUMERIC = {\n        id: 'Numeric',\n        bit: 1 << 0,\n        ccBits: [10, 12, 14]\n    };\n    /**\n     * Alphanumeric mode encodes data from a set of 45 characters,\n     * i.e. 10 numeric digits (0 - 9),\n     *      26 alphabetic characters (A - Z),\n     *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n     * Normally, two input characters are represented by 11 bits.\n     *\n     * @type {Object}\n     */\n    exports.ALPHANUMERIC = {\n        id: 'Alphanumeric',\n        bit: 1 << 1,\n        ccBits: [9, 11, 13]\n    };\n    /**\n     * In byte mode, data is encoded at 8 bits per character.\n     *\n     * @type {Object}\n     */\n    exports.BYTE = {\n        id: 'Byte',\n        bit: 1 << 2,\n        ccBits: [8, 16, 16]\n    };\n    /**\n     * The Kanji mode efficiently encodes Kanji characters in accordance with\n     * the Shift JIS system based on JIS X 0208.\n     * The Shift JIS values are shifted from the JIS X 0208 values.\n     * JIS X 0208 gives details of the shift coded representation.\n     * Each two-byte character value is compacted to a 13-bit binary codeword.\n     *\n     * @type {Object}\n     */\n    exports.KANJI = {\n        id: 'Kanji',\n        bit: 1 << 3,\n        ccBits: [8, 10, 12]\n    };\n    /**\n     * Mixed mode will contain a sequences of data in a combination of any of\n     * the modes described above\n     *\n     * @type {Object}\n     */\n    exports.MIXED = {\n        bit: -1\n    };\n    /**\n     * Returns the number of bits needed to store the data length\n     * according to QR Code specifications.\n     *\n     * @param  {Mode}   mode    Data mode\n     * @param  {Number} version QR Code version\n     * @return {Number}         Number of bits\n     */\n    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n        if (!mode.ccBits)\n            throw new Error('Invalid mode: ' + mode);\n        if (!versionCheck.isValid(version)) {\n            throw new Error('Invalid version: ' + version);\n        }\n        if (version >= 1 && version < 10)\n            return mode.ccBits[0];\n        else if (version < 27)\n            return mode.ccBits[1];\n        return mode.ccBits[2];\n    };\n    /**\n     * Returns the most efficient mode to store the specified data\n     *\n     * @param  {String} dataStr Input data string\n     * @return {Mode}           Best mode\n     */\n    exports.getBestModeForData = function getBestModeForData(dataStr) {\n        if (regex.testNumeric(dataStr))\n            return exports.NUMERIC;\n        else if (regex.testAlphanumeric(dataStr))\n            return exports.ALPHANUMERIC;\n        else if (regex.testKanji(dataStr))\n            return exports.KANJI;\n        else\n            return exports.BYTE;\n    };\n    /**\n     * Return mode name as string\n     *\n     * @param {Mode} mode Mode object\n     * @returns {String}  Mode name\n     */\n    exports.toString = function toString(mode) {\n        if (mode && mode.id)\n            return mode.id;\n        throw new Error('Invalid mode');\n    };\n    /**\n     * Check if input param is a valid mode object\n     *\n     * @param   {Mode}    mode Mode object\n     * @returns {Boolean} True if valid mode, false otherwise\n     */\n    exports.isValid = function isValid(mode) {\n        return mode && mode.bit && mode.ccBits;\n    };\n    /**\n     * Get mode object from its name\n     *\n     * @param   {String} string Mode name\n     * @returns {Mode}          Mode object\n     */\n    function fromString(string) {\n        if (typeof string !== 'string') {\n            throw new Error('Param is not a string');\n        }\n        var lcStr = string.toLowerCase();\n        switch (lcStr) {\n            case 'numeric':\n                return exports.NUMERIC;\n            case 'alphanumeric':\n                return exports.ALPHANUMERIC;\n            case 'kanji':\n                return exports.KANJI;\n            case 'byte':\n                return exports.BYTE;\n            default:\n                throw new Error('Unknown mode: ' + string);\n        }\n    }\n    /**\n     * Returns mode from a value.\n     * If value is not a valid mode, returns defaultValue\n     *\n     * @param  {Mode|String} value        Encoding mode\n     * @param  {Mode}        defaultValue Fallback value\n     * @return {Mode}                     Encoding mode\n     */\n    exports.from = function from(value, defaultValue) {\n        if (exports.isValid(value)) {\n            return value;\n        }\n        try {\n            return fromString(value);\n        }\n        catch (e) {\n            return defaultValue;\n        }\n    };\n});\nvar version = createCommonjsModule(function (module, exports) {\n    // Generator polynomial used to encode version information\n    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);\n    var G18_BCH = utils.getBCHDigit(G18);\n    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n                return currentVersion;\n            }\n        }\n        return undefined;\n    }\n    function getReservedBitsCount(mode$1, version) {\n        // Character count indicator + mode indicator bits\n        return mode.getCharCountIndicator(mode$1, version) + 4;\n    }\n    function getTotalBitsFromDataArray(segments, version) {\n        var totalBits = 0;\n        segments.forEach(function (data) {\n            var reservedBits = getReservedBitsCount(data.mode, version);\n            totalBits += reservedBits + data.getBitsLength();\n        });\n        return totalBits;\n    }\n    function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n            var length = getTotalBitsFromDataArray(segments, currentVersion);\n            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode.MIXED)) {\n                return currentVersion;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Returns version number from a value.\n     * If value is not a valid version, returns defaultValue\n     *\n     * @param  {Number|String} value        QR Code version\n     * @param  {Number}        defaultValue Fallback value\n     * @return {Number}                     QR Code version number\n     */\n    exports.from = function from(value, defaultValue) {\n        if (versionCheck.isValid(value)) {\n            return parseInt(value, 10);\n        }\n        return defaultValue;\n    };\n    /**\n     * Returns how much data can be stored with the specified QR code version\n     * and error correction level\n     *\n     * @param  {Number} version              QR Code version (1-40)\n     * @param  {Number} errorCorrectionLevel Error correction level\n     * @param  {Mode}   mode                 Data mode\n     * @return {Number}                      Quantity of storable data\n     */\n    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode$1) {\n        if (!versionCheck.isValid(version)) {\n            throw new Error('Invalid QR Code version');\n        }\n        // Use Byte mode as default\n        if (typeof mode$1 === 'undefined')\n            mode$1 = mode.BYTE;\n        // Total codewords for this QR code version (Data + Error correction)\n        var totalCodewords = utils.getSymbolTotalCodewords(version);\n        // Total number of error correction codewords\n        var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n        // Total number of data codewords\n        var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n        if (mode$1 === mode.MIXED)\n            return dataTotalCodewordsBits;\n        var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode$1, version);\n        // Return max number of storable codewords\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return Math.floor((usableBits / 10) * 3);\n            case mode.ALPHANUMERIC:\n                return Math.floor((usableBits / 11) * 2);\n            case mode.KANJI:\n                return Math.floor(usableBits / 13);\n            case mode.BYTE:\n            default:\n                return Math.floor(usableBits / 8);\n        }\n    };\n    /**\n     * Returns the minimum version needed to contain the amount of data\n     *\n     * @param  {Segment} data                    Segment of data\n     * @param  {Number} [errorCorrectionLevel=H] Error correction level\n     * @param  {Mode} mode                       Data mode\n     * @return {Number}                          QR Code version\n     */\n    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel$1) {\n        var seg;\n        var ecl = errorCorrectionLevel.from(errorCorrectionLevel$1, errorCorrectionLevel.M);\n        if (isarray(data)) {\n            if (data.length > 1) {\n                return getBestVersionForMixedData(data, ecl);\n            }\n            if (data.length === 0) {\n                return 1;\n            }\n            seg = data[0];\n        }\n        else {\n            seg = data;\n        }\n        return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n    };\n    /**\n     * Returns version information with relative error correction bits\n     *\n     * The version information is included in QR Code symbols of version 7 or larger.\n     * It consists of an 18-bit sequence containing 6 data bits,\n     * with 12 error correction bits calculated using the (18, 6) Golay code.\n     *\n     * @param  {Number} version QR Code version\n     * @return {Number}         Encoded version info bits\n     */\n    exports.getEncodedBits = function getEncodedBits(version) {\n        if (!versionCheck.isValid(version) || version < 7) {\n            throw new Error('Invalid QR Code version');\n        }\n        var d = version << 12;\n        while (utils.getBCHDigit(d) - G18_BCH >= 0) {\n            d ^= (G18 << (utils.getBCHDigit(d) - G18_BCH));\n        }\n        return (version << 12) | d;\n    };\n});\nvar G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);\nvar G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);\nvar G15_BCH = utils.getBCHDigit(G15);\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nvar getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n    var data = ((errorCorrectionLevel.bit << 3) | mask);\n    var d = data << 10;\n    while (utils.getBCHDigit(d) - G15_BCH >= 0) {\n        d ^= (G15 << (utils.getBCHDigit(d) - G15_BCH));\n    }\n    // xor final data with mask pattern in order to ensure that\n    // no combination of Error Correction Level and data mask pattern\n    // will result in an all-zero data string\n    return ((data << 10) | d) ^ G15_MASK;\n};\nvar formatInfo = {\n    getEncodedBits: getEncodedBits\n};\nfunction NumericData(data) {\n    this.mode = mode.NUMERIC;\n    this.data = data.toString();\n}\nNumericData.getBitsLength = function getBitsLength(length) {\n    return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0);\n};\nNumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nNumericData.prototype.getBitsLength = function getBitsLength() {\n    return NumericData.getBitsLength(this.data.length);\n};\nNumericData.prototype.write = function write(bitBuffer) {\n    var i, group, value;\n    // The input data string is divided into groups of three digits,\n    // and each group is converted to its 10-bit binary equivalent.\n    for (i = 0; i + 3 <= this.data.length; i += 3) {\n        group = this.data.substr(i, 3);\n        value = parseInt(group, 10);\n        bitBuffer.put(value, 10);\n    }\n    // If the number of input digits is not an exact multiple of three,\n    // the final one or two digits are converted to 4 or 7 bits respectively.\n    var remainingNum = this.data.length - i;\n    if (remainingNum > 0) {\n        group = this.data.substr(i);\n        value = parseInt(group, 10);\n        bitBuffer.put(value, remainingNum * 3 + 1);\n    }\n};\nvar numericData = NumericData;\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nvar ALPHA_NUM_CHARS = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n];\nfunction AlphanumericData(data) {\n    this.mode = mode.ALPHANUMERIC;\n    this.data = data;\n}\nAlphanumericData.getBitsLength = function getBitsLength(length) {\n    return 11 * Math.floor(length / 2) + 6 * (length % 2);\n};\nAlphanumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nAlphanumericData.prototype.getBitsLength = function getBitsLength() {\n    return AlphanumericData.getBitsLength(this.data.length);\n};\nAlphanumericData.prototype.write = function write(bitBuffer) {\n    var i;\n    // Input data characters are divided into groups of two characters\n    // and encoded as 11-bit binary codes.\n    for (i = 0; i + 2 <= this.data.length; i += 2) {\n        // The character value of the first character is multiplied by 45\n        var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;\n        // The character value of the second digit is added to the product\n        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);\n        // The sum is then stored as 11-bit binary number\n        bitBuffer.put(value, 11);\n    }\n    // If the number of input data characters is not a multiple of two,\n    // the character value of the final character is encoded as a 6-bit binary number.\n    if (this.data.length % 2) {\n        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n    }\n};\nvar alphanumericData = AlphanumericData;\nfunction ByteData(data) {\n    this.mode = mode.BYTE;\n    this.data = typedarrayBuffer.from(data);\n}\nByteData.getBitsLength = function getBitsLength(length) {\n    return length * 8;\n};\nByteData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nByteData.prototype.getBitsLength = function getBitsLength() {\n    return ByteData.getBitsLength(this.data.length);\n};\nByteData.prototype.write = function (bitBuffer) {\n    for (var i = 0, l = this.data.length; i < l; i++) {\n        bitBuffer.put(this.data[i], 8);\n    }\n};\nvar byteData = ByteData;\nfunction KanjiData(data) {\n    this.mode = mode.KANJI;\n    this.data = data;\n}\nKanjiData.getBitsLength = function getBitsLength(length) {\n    return length * 13;\n};\nKanjiData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nKanjiData.prototype.getBitsLength = function getBitsLength() {\n    return KanjiData.getBitsLength(this.data.length);\n};\nKanjiData.prototype.write = function (bitBuffer) {\n    var i;\n    // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n    // These byte values are shifted from the JIS X 0208 values.\n    // JIS X 0208 gives details of the shift coded representation.\n    for (i = 0; i < this.data.length; i++) {\n        var value = utils.toSJIS(this.data[i]);\n        // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n        if (value >= 0x8140 && value <= 0x9FFC) {\n            // Subtract 0x8140 from Shift JIS value\n            value -= 0x8140;\n            // For characters with Shift JIS values from 0xE040 to 0xEBBF\n        }\n        else if (value >= 0xE040 && value <= 0xEBBF) {\n            // Subtract 0xC140 from Shift JIS value\n            value -= 0xC140;\n        }\n        else {\n            throw new Error('Invalid SJIS character: ' + this.data[i] + '\\n' +\n                'Make sure your charset is UTF-8');\n        }\n        // Multiply most significant byte of result by 0xC0\n        // and add least significant byte to product\n        value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);\n        // Convert result to a 13-bit binary string\n        bitBuffer.put(value, 13);\n    }\n};\nvar kanjiData = KanjiData;\nvar dijkstra_1 = createCommonjsModule(function (module) {\n    /******************************************************************************\n     * Created 2008-08-19.\n     *\n     * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n     *\n     * Copyright (C) 2008\n     *   Wyatt Baldwin <self@wyattbaldwin.com>\n     *   All rights reserved\n     *\n     * Licensed under the MIT license.\n     *\n     *   http://www.opensource.org/licenses/mit-license.php\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     * THE SOFTWARE.\n     *****************************************************************************/\n    var dijkstra = {\n        single_source_shortest_paths: function (graph, s, d) {\n            // Predecessor map for each node that has been encountered.\n            // node ID => predecessor node ID\n            var predecessors = {};\n            // Costs of shortest paths from s to all nodes encountered.\n            // node ID => cost\n            var costs = {};\n            costs[s] = 0;\n            // Costs of shortest paths from s to all nodes encountered; differs from\n            // `costs` in that it provides easy access to the node that currently has\n            // the known shortest path from s.\n            // XXX: Do we actually need both `costs` and `open`?\n            var open = dijkstra.PriorityQueue.make();\n            open.push(s, 0);\n            var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n            while (!open.empty()) {\n                // In the nodes remaining in graph that have a known cost from s,\n                // find the node, u, that currently has the shortest path from s.\n                closest = open.pop();\n                u = closest.value;\n                cost_of_s_to_u = closest.cost;\n                // Get nodes adjacent to u...\n                adjacent_nodes = graph[u] || {};\n                // ...and explore the edges that connect u to those nodes, updating\n                // the cost of the shortest paths to any or all of those nodes as\n                // necessary. v is the node across the current edge from u.\n                for (v in adjacent_nodes) {\n                    if (adjacent_nodes.hasOwnProperty(v)) {\n                        // Get the cost of the edge running from u to v.\n                        cost_of_e = adjacent_nodes[v];\n                        // Cost of s to u plus the cost of u to v across e--this is *a*\n                        // cost from s to v that may or may not be less than the current\n                        // known cost to v.\n                        cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n                        // If we haven't visited v yet OR if the current known cost from s to\n                        // v is greater than the new cost we just found (cost of s to u plus\n                        // cost of u to v across e), update v's cost in the cost list and\n                        // update v's predecessor in the predecessor list (it's now u).\n                        cost_of_s_to_v = costs[v];\n                        first_visit = (typeof costs[v] === 'undefined');\n                        if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n                            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n                            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n                            predecessors[v] = u;\n                        }\n                    }\n                }\n            }\n            if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n                var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n                throw new Error(msg);\n            }\n            return predecessors;\n        },\n        extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n            var nodes = [];\n            var u = d;\n            while (u) {\n                nodes.push(u);\n                u = predecessors[u];\n            }\n            nodes.reverse();\n            return nodes;\n        },\n        find_path: function (graph, s, d) {\n            var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n            return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n        },\n        /**\n         * A very naive priority queue implementation.\n         */\n        PriorityQueue: {\n            make: function (opts) {\n                var T = dijkstra.PriorityQueue, t = {}, key;\n                opts = opts || {};\n                for (key in T) {\n                    if (T.hasOwnProperty(key)) {\n                        t[key] = T[key];\n                    }\n                }\n                t.queue = [];\n                t.sorter = opts.sorter || T.default_sorter;\n                return t;\n            },\n            default_sorter: function (a, b) {\n                return a.cost - b.cost;\n            },\n            /**\n             * Add a new item to the queue and ensure the highest priority element\n             * is at the front of the queue.\n             */\n            push: function (value, cost) {\n                var item = { value: value, cost: cost };\n                this.queue.push(item);\n                this.queue.sort(this.sorter);\n            },\n            /**\n             * Return the highest priority element in the queue.\n             */\n            pop: function () {\n                return this.queue.shift();\n            },\n            empty: function () {\n                return this.queue.length === 0;\n            }\n        }\n    };\n    // node.js module exports\n    {\n        module.exports = dijkstra;\n    }\n});\nvar segments = createCommonjsModule(function (module, exports) {\n    /**\n     * Returns UTF8 byte length\n     *\n     * @param  {String} str Input string\n     * @return {Number}     Number of byte\n     */\n    function getStringByteLength(str) {\n        return unescape(encodeURIComponent(str)).length;\n    }\n    /**\n     * Get a list of segments of the specified mode\n     * from a string\n     *\n     * @param  {Mode}   mode Segment mode\n     * @param  {String} str  String to process\n     * @return {Array}       Array of object with segments data\n     */\n    function getSegments(regex, mode, str) {\n        var segments = [];\n        var result;\n        while ((result = regex.exec(str)) !== null) {\n            segments.push({\n                data: result[0],\n                index: result.index,\n                mode: mode,\n                length: result[0].length\n            });\n        }\n        return segments;\n    }\n    /**\n     * Extracts a series of segments with the appropriate\n     * modes from a string\n     *\n     * @param  {String} dataStr Input string\n     * @return {Array}          Array of object with segments data\n     */\n    function getSegmentsFromString(dataStr) {\n        var numSegs = getSegments(regex.NUMERIC, mode.NUMERIC, dataStr);\n        var alphaNumSegs = getSegments(regex.ALPHANUMERIC, mode.ALPHANUMERIC, dataStr);\n        var byteSegs;\n        var kanjiSegs;\n        if (utils.isKanjiModeEnabled()) {\n            byteSegs = getSegments(regex.BYTE, mode.BYTE, dataStr);\n            kanjiSegs = getSegments(regex.KANJI, mode.KANJI, dataStr);\n        }\n        else {\n            byteSegs = getSegments(regex.BYTE_KANJI, mode.BYTE, dataStr);\n            kanjiSegs = [];\n        }\n        var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n        return segs\n            .sort(function (s1, s2) {\n            return s1.index - s2.index;\n        })\n            .map(function (obj) {\n            return {\n                data: obj.data,\n                mode: obj.mode,\n                length: obj.length\n            };\n        });\n    }\n    /**\n     * Returns how many bits are needed to encode a string of\n     * specified length with the specified mode\n     *\n     * @param  {Number} length String length\n     * @param  {Mode} mode     Segment mode\n     * @return {Number}        Bit length\n     */\n    function getSegmentBitsLength(length, mode$1) {\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return numericData.getBitsLength(length);\n            case mode.ALPHANUMERIC:\n                return alphanumericData.getBitsLength(length);\n            case mode.KANJI:\n                return kanjiData.getBitsLength(length);\n            case mode.BYTE:\n                return byteData.getBitsLength(length);\n        }\n    }\n    /**\n     * Merges adjacent segments which have the same mode\n     *\n     * @param  {Array} segs Array of object with segments data\n     * @return {Array}      Array of object with segments data\n     */\n    function mergeSegments(segs) {\n        return segs.reduce(function (acc, curr) {\n            var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n            if (prevSeg && prevSeg.mode === curr.mode) {\n                acc[acc.length - 1].data += curr.data;\n                return acc;\n            }\n            acc.push(curr);\n            return acc;\n        }, []);\n    }\n    /**\n     * Generates a list of all possible nodes combination which\n     * will be used to build a segments graph.\n     *\n     * Nodes are divided by groups. Each group will contain a list of all the modes\n     * in which is possible to encode the given text.\n     *\n     * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n     * The group for '12345' will contain then 3 objects, one for each\n     * possible encoding mode.\n     *\n     * Each node represents a possible segment.\n     *\n     * @param  {Array} segs Array of object with segments data\n     * @return {Array}      Array of object with segments data\n     */\n    function buildNodes(segs) {\n        var nodes = [];\n        for (var i = 0; i < segs.length; i++) {\n            var seg = segs[i];\n            switch (seg.mode) {\n                case mode.NUMERIC:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.ALPHANUMERIC, length: seg.length },\n                        { data: seg.data, mode: mode.BYTE, length: seg.length }\n                    ]);\n                    break;\n                case mode.ALPHANUMERIC:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.BYTE, length: seg.length }\n                    ]);\n                    break;\n                case mode.KANJI:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }\n                    ]);\n                    break;\n                case mode.BYTE:\n                    nodes.push([\n                        { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }\n                    ]);\n            }\n        }\n        return nodes;\n    }\n    /**\n     * Builds a graph from a list of nodes.\n     * All segments in each node group will be connected with all the segments of\n     * the next group and so on.\n     *\n     * At each connection will be assigned a weight depending on the\n     * segment's byte length.\n     *\n     * @param  {Array} nodes    Array of object with segments data\n     * @param  {Number} version QR Code version\n     * @return {Object}         Graph of all possible segments\n     */\n    function buildGraph(nodes, version) {\n        var table = {};\n        var graph = { 'start': {} };\n        var prevNodeIds = ['start'];\n        for (var i = 0; i < nodes.length; i++) {\n            var nodeGroup = nodes[i];\n            var currentNodeIds = [];\n            for (var j = 0; j < nodeGroup.length; j++) {\n                var node = nodeGroup[j];\n                var key = '' + i + j;\n                currentNodeIds.push(key);\n                table[key] = { node: node, lastCount: 0 };\n                graph[key] = {};\n                for (var n = 0; n < prevNodeIds.length; n++) {\n                    var prevNodeId = prevNodeIds[n];\n                    if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n                        graph[prevNodeId][key] =\n                            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n                                getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n                        table[prevNodeId].lastCount += node.length;\n                    }\n                    else {\n                        if (table[prevNodeId])\n                            table[prevNodeId].lastCount = node.length;\n                        graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n                            4 + mode.getCharCountIndicator(node.mode, version); // switch cost\n                    }\n                }\n            }\n            prevNodeIds = currentNodeIds;\n        }\n        for (n = 0; n < prevNodeIds.length; n++) {\n            graph[prevNodeIds[n]]['end'] = 0;\n        }\n        return { map: graph, table: table };\n    }\n    /**\n     * Builds a segment from a specified data and mode.\n     * If a mode is not specified, the more suitable will be used.\n     *\n     * @param  {String} data             Input data\n     * @param  {Mode | String} modesHint Data mode\n     * @return {Segment}                 Segment\n     */\n    function buildSingleSegment(data, modesHint) {\n        var mode$1;\n        var bestMode = mode.getBestModeForData(data);\n        mode$1 = mode.from(modesHint, bestMode);\n        // Make sure data can be encoded\n        if (mode$1 !== mode.BYTE && mode$1.bit < bestMode.bit) {\n            throw new Error('\"' + data + '\"' +\n                ' cannot be encoded with mode ' + mode.toString(mode$1) +\n                '.\\n Suggested mode is: ' + mode.toString(bestMode));\n        }\n        // Use Mode.BYTE if Kanji support is disabled\n        if (mode$1 === mode.KANJI && !utils.isKanjiModeEnabled()) {\n            mode$1 = mode.BYTE;\n        }\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return new numericData(data);\n            case mode.ALPHANUMERIC:\n                return new alphanumericData(data);\n            case mode.KANJI:\n                return new kanjiData(data);\n            case mode.BYTE:\n                return new byteData(data);\n        }\n    }\n    /**\n     * Builds a list of segments from an array.\n     * Array can contain Strings or Objects with segment's info.\n     *\n     * For each item which is a string, will be generated a segment with the given\n     * string and the more appropriate encoding mode.\n     *\n     * For each item which is an object, will be generated a segment with the given\n     * data and mode.\n     * Objects must contain at least the property \"data\".\n     * If property \"mode\" is not present, the more suitable mode will be used.\n     *\n     * @param  {Array} array Array of objects with segments data\n     * @return {Array}       Array of Segments\n     */\n    exports.fromArray = function fromArray(array) {\n        return array.reduce(function (acc, seg) {\n            if (typeof seg === 'string') {\n                acc.push(buildSingleSegment(seg, null));\n            }\n            else if (seg.data) {\n                acc.push(buildSingleSegment(seg.data, seg.mode));\n            }\n            return acc;\n        }, []);\n    };\n    /**\n     * Builds an optimized sequence of segments from a string,\n     * which will produce the shortest possible bitstream.\n     *\n     * @param  {String} data    Input string\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of segments\n     */\n    exports.fromString = function fromString(data, version) {\n        var segs = getSegmentsFromString(data, utils.isKanjiModeEnabled());\n        var nodes = buildNodes(segs);\n        var graph = buildGraph(nodes, version);\n        var path = dijkstra_1.find_path(graph.map, 'start', 'end');\n        var optimizedSegs = [];\n        for (var i = 1; i < path.length - 1; i++) {\n            optimizedSegs.push(graph.table[path[i]].node);\n        }\n        return exports.fromArray(mergeSegments(optimizedSegs));\n    };\n    /**\n     * Splits a string in various segments with the modes which\n     * best represent their content.\n     * The produced segments are far from being optimized.\n     * The output of this function is only used to estimate a QR Code version\n     * which may contain the data.\n     *\n     * @param  {string} data Input string\n     * @return {Array}       Array of segments\n     */\n    exports.rawSplit = function rawSplit(data) {\n        return exports.fromArray(getSegmentsFromString(data, utils.isKanjiModeEnabled()));\n    };\n});\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern(matrix, version) {\n    var size = matrix.size;\n    var pos = finderPattern.getPositions(version);\n    for (var i = 0; i < pos.length; i++) {\n        var row = pos[i][0];\n        var col = pos[i][1];\n        for (var r = -1; r <= 7; r++) {\n            if (row + r <= -1 || size <= row + r)\n                continue;\n            for (var c = -1; c <= 7; c++) {\n                if (col + c <= -1 || size <= col + c)\n                    continue;\n                if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n                    (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n                    (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n                    matrix.set(row + r, col + c, true, true);\n                }\n                else {\n                    matrix.set(row + r, col + c, false, true);\n                }\n            }\n        }\n    }\n}\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern(matrix) {\n    var size = matrix.size;\n    for (var r = 8; r < size - 8; r++) {\n        var value = r % 2 === 0;\n        matrix.set(r, 6, value, true);\n        matrix.set(6, r, value, true);\n    }\n}\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern(matrix, version) {\n    var pos = alignmentPattern.getPositions(version);\n    for (var i = 0; i < pos.length; i++) {\n        var row = pos[i][0];\n        var col = pos[i][1];\n        for (var r = -2; r <= 2; r++) {\n            for (var c = -2; c <= 2; c++) {\n                if (r === -2 || r === 2 || c === -2 || c === 2 ||\n                    (r === 0 && c === 0)) {\n                    matrix.set(row + r, col + c, true, true);\n                }\n                else {\n                    matrix.set(row + r, col + c, false, true);\n                }\n            }\n        }\n    }\n}\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo(matrix, version$1) {\n    var size = matrix.size;\n    var bits = version.getEncodedBits(version$1);\n    var row, col, mod;\n    for (var i = 0; i < 18; i++) {\n        row = Math.floor(i / 3);\n        col = i % 3 + size - 8 - 3;\n        mod = ((bits >> i) & 1) === 1;\n        matrix.set(row, col, mod, true);\n        matrix.set(col, row, mod, true);\n    }\n}\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n    var size = matrix.size;\n    var bits = formatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n    var i, mod;\n    for (i = 0; i < 15; i++) {\n        mod = ((bits >> i) & 1) === 1;\n        // vertical\n        if (i < 6) {\n            matrix.set(i, 8, mod, true);\n        }\n        else if (i < 8) {\n            matrix.set(i + 1, 8, mod, true);\n        }\n        else {\n            matrix.set(size - 15 + i, 8, mod, true);\n        }\n        // horizontal\n        if (i < 8) {\n            matrix.set(8, size - i - 1, mod, true);\n        }\n        else if (i < 9) {\n            matrix.set(8, 15 - i - 1 + 1, mod, true);\n        }\n        else {\n            matrix.set(8, 15 - i - 1, mod, true);\n        }\n    }\n    // fixed module\n    matrix.set(size - 8, 8, 1, true);\n}\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\nfunction setupData(matrix, data) {\n    var size = matrix.size;\n    var inc = -1;\n    var row = size - 1;\n    var bitIndex = 7;\n    var byteIndex = 0;\n    for (var col = size - 1; col > 0; col -= 2) {\n        if (col === 6)\n            col--;\n        while (true) {\n            for (var c = 0; c < 2; c++) {\n                if (!matrix.isReserved(row, col - c)) {\n                    var dark = false;\n                    if (byteIndex < data.length) {\n                        dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);\n                    }\n                    matrix.set(row, col - c, dark);\n                    bitIndex--;\n                    if (bitIndex === -1) {\n                        byteIndex++;\n                        bitIndex = 7;\n                    }\n                }\n            }\n            row += inc;\n            if (row < 0 || size <= row) {\n                row -= inc;\n                inc = -inc;\n                break;\n            }\n        }\n    }\n}\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\nfunction createData(version, errorCorrectionLevel, segments) {\n    // Prepare data buffer\n    var buffer = new bitBuffer();\n    segments.forEach(function (data) {\n        // prefix data with mode indicator (4 bits)\n        buffer.put(data.mode.bit, 4);\n        // Prefix data with character count indicator.\n        // The character count indicator is a string of bits that represents the\n        // number of characters that are being encoded.\n        // The character count indicator must be placed after the mode indicator\n        // and must be a certain number of bits long, depending on the QR version\n        // and data mode\n        // @see {@link Mode.getCharCountIndicator}.\n        buffer.put(data.getLength(), mode.getCharCountIndicator(data.mode, version));\n        // add binary data sequence to buffer\n        data.write(buffer);\n    });\n    // Calculate required number of bits\n    var totalCodewords = utils.getSymbolTotalCodewords(version);\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    // Add a terminator.\n    // If the bit string is shorter than the total number of required bits,\n    // a terminator of up to four 0s must be added to the right side of the string.\n    // If the bit string is more than four bits shorter than the required number of bits,\n    // add four 0s to the end.\n    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n        buffer.put(0, 4);\n    }\n    // If the bit string is fewer than four bits shorter, add only the number of 0s that\n    // are needed to reach the required number of bits.\n    // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n    // pad the string on the right with 0s to make the string's length a multiple of 8.\n    while (buffer.getLengthInBits() % 8 !== 0) {\n        buffer.putBit(0);\n    }\n    // Add pad bytes if the string is still shorter than the total number of required bits.\n    // Extend the buffer to fill the data capacity of the symbol corresponding to\n    // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n    // and 00010001 (0x11) alternately.\n    var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n    for (var i = 0; i < remainingByte; i++) {\n        buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n    }\n    return createCodewords(buffer, version, errorCorrectionLevel);\n}\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\nfunction createCodewords(bitBuffer, version, errorCorrectionLevel) {\n    // Total codewords for this QR code version (Data + Error correction)\n    var totalCodewords = utils.getSymbolTotalCodewords(version);\n    // Total number of error correction codewords\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    // Total number of data codewords\n    var dataTotalCodewords = totalCodewords - ecTotalCodewords;\n    // Total number of blocks\n    var ecTotalBlocks = errorCorrectionCode.getBlocksCount(version, errorCorrectionLevel);\n    // Calculate how many blocks each group should contain\n    var blocksInGroup2 = totalCodewords % ecTotalBlocks;\n    var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n    var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n    var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n    var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;\n    // Number of EC codewords is the same for both groups\n    var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;\n    // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n    var rs = new reedSolomonEncoder(ecCount);\n    var offset = 0;\n    var dcData = new Array(ecTotalBlocks);\n    var ecData = new Array(ecTotalBlocks);\n    var maxDataSize = 0;\n    var buffer = typedarrayBuffer.from(bitBuffer.buffer);\n    // Divide the buffer into the required number of blocks\n    for (var b = 0; b < ecTotalBlocks; b++) {\n        var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;\n        // extract a block of data from buffer\n        dcData[b] = buffer.slice(offset, offset + dataSize);\n        // Calculate EC codewords for this data block\n        ecData[b] = rs.encode(dcData[b]);\n        offset += dataSize;\n        maxDataSize = Math.max(maxDataSize, dataSize);\n    }\n    // Create final data\n    // Interleave the data and error correction codewords from each block\n    var data = typedarrayBuffer.alloc(totalCodewords);\n    var index = 0;\n    var i, r;\n    // Add data codewords\n    for (i = 0; i < maxDataSize; i++) {\n        for (r = 0; r < ecTotalBlocks; r++) {\n            if (i < dcData[r].length) {\n                data[index++] = dcData[r][i];\n            }\n        }\n    }\n    // Apped EC codewords\n    for (i = 0; i < ecCount; i++) {\n        for (r = 0; r < ecTotalBlocks; r++) {\n            data[index++] = ecData[r][i];\n        }\n    }\n    return data;\n}\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol(data, version$1, errorCorrectionLevel, maskPattern$1) {\n    var segments$1;\n    if (isarray(data)) {\n        segments$1 = segments.fromArray(data);\n    }\n    else if (typeof data === 'string') {\n        var estimatedVersion = version$1;\n        if (!estimatedVersion) {\n            var rawSegments = segments.rawSplit(data);\n            // Estimate best version that can contain raw splitted segments\n            estimatedVersion = version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n        }\n        // Build optimized segments\n        // If estimated version is undefined, try with the highest version\n        segments$1 = segments.fromString(data, estimatedVersion || 40);\n    }\n    else {\n        throw new Error('Invalid data');\n    }\n    // Get the min version that can contain data\n    var bestVersion = version.getBestVersionForData(segments$1, errorCorrectionLevel);\n    // If no version is found, data cannot be stored\n    if (!bestVersion) {\n        throw new Error('The amount of data is too big to be stored in a QR Code');\n    }\n    // If not specified, use min version as default\n    if (!version$1) {\n        version$1 = bestVersion;\n        // Check if the specified version can contain the data\n    }\n    else if (version$1 < bestVersion) {\n        throw new Error('\\n' +\n            'The chosen QR Code version cannot contain this amount of data.\\n' +\n            'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n    }\n    var dataBits = createData(version$1, errorCorrectionLevel, segments$1);\n    // Allocate matrix buffer\n    var moduleCount = utils.getSymbolSize(version$1);\n    var modules = new bitMatrix(moduleCount);\n    // Add function modules\n    setupFinderPattern(modules, version$1);\n    setupTimingPattern(modules);\n    setupAlignmentPattern(modules, version$1);\n    // Add temporary dummy bits for format info just to set them as reserved.\n    // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n    // since the masking operation must be performed only on the encoding region.\n    // These blocks will be replaced with correct values later in code.\n    setupFormatInfo(modules, errorCorrectionLevel, 0);\n    if (version$1 >= 7) {\n        setupVersionInfo(modules, version$1);\n    }\n    // Add data codewords\n    setupData(modules, dataBits);\n    if (isNaN(maskPattern$1)) {\n        // Find best mask pattern\n        maskPattern$1 = maskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n    }\n    // Apply mask pattern\n    maskPattern.applyMask(maskPattern$1, modules);\n    // Replace format info bits with correct values\n    setupFormatInfo(modules, errorCorrectionLevel, maskPattern$1);\n    return {\n        modules: modules,\n        version: version$1,\n        errorCorrectionLevel: errorCorrectionLevel,\n        maskPattern: maskPattern$1,\n        segments: segments$1\n    };\n}\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nvar create = function create(data, options) {\n    if (typeof data === 'undefined' || data === '') {\n        throw new Error('No input text');\n    }\n    var errorCorrectionLevel$1 = errorCorrectionLevel.M;\n    var version$1;\n    var mask;\n    if (typeof options !== 'undefined') {\n        // Use higher error correction level as default\n        errorCorrectionLevel$1 = errorCorrectionLevel.from(options.errorCorrectionLevel, errorCorrectionLevel.M);\n        version$1 = version.from(options.version);\n        mask = maskPattern.from(options.maskPattern);\n        if (options.toSJISFunc) {\n            utils.setToSJISFunction(options.toSJISFunc);\n        }\n    }\n    return createSymbol(data, version$1, errorCorrectionLevel$1, mask);\n};\nvar qrcode = {\n    create: create\n};\nvar utils$1 = createCommonjsModule(function (module, exports) {\n    function hex2rgba(hex) {\n        if (typeof hex === 'number') {\n            hex = hex.toString();\n        }\n        if (typeof hex !== 'string') {\n            throw new Error('Color should be defined as hex string');\n        }\n        var hexCode = hex.slice().replace('#', '').split('');\n        if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n            throw new Error('Invalid hex color: ' + hex);\n        }\n        // Convert from short to long form (fff -> ffffff)\n        if (hexCode.length === 3 || hexCode.length === 4) {\n            hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n                return [c, c];\n            }));\n        }\n        // Add default alpha value\n        if (hexCode.length === 6)\n            hexCode.push('F', 'F');\n        var hexValue = parseInt(hexCode.join(''), 16);\n        return {\n            r: (hexValue >> 24) & 255,\n            g: (hexValue >> 16) & 255,\n            b: (hexValue >> 8) & 255,\n            a: hexValue & 255,\n            hex: '#' + hexCode.slice(0, 6).join('')\n        };\n    }\n    exports.getOptions = function getOptions(options) {\n        if (!options)\n            options = {};\n        if (!options.color)\n            options.color = {};\n        var margin = typeof options.margin === 'undefined' ||\n            options.margin === null ||\n            options.margin < 0 ? 4 : options.margin;\n        var width = options.width && options.width >= 21 ? options.width : undefined;\n        var scale = options.scale || 4;\n        return {\n            width: width,\n            scale: width ? 4 : scale,\n            margin: margin,\n            color: {\n                dark: hex2rgba(options.color.dark || '#000000ff'),\n                light: hex2rgba(options.color.light || '#ffffffff')\n            },\n            type: options.type,\n            rendererOpts: options.rendererOpts || {}\n        };\n    };\n    exports.getScale = function getScale(qrSize, opts) {\n        return opts.width && opts.width >= qrSize + opts.margin * 2\n            ? opts.width / (qrSize + opts.margin * 2)\n            : opts.scale;\n    };\n    exports.getImageWidth = function getImageWidth(qrSize, opts) {\n        var scale = exports.getScale(qrSize, opts);\n        return Math.floor((qrSize + opts.margin * 2) * scale);\n    };\n    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n        var size = qr.modules.size;\n        var data = qr.modules.data;\n        var scale = exports.getScale(size, opts);\n        var symbolSize = Math.floor((size + opts.margin * 2) * scale);\n        var scaledMargin = opts.margin * scale;\n        var palette = [opts.color.light, opts.color.dark];\n        for (var i = 0; i < symbolSize; i++) {\n            for (var j = 0; j < symbolSize; j++) {\n                var posDst = (i * symbolSize + j) * 4;\n                var pxColor = opts.color.light;\n                if (i >= scaledMargin && j >= scaledMargin &&\n                    i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n                    var iSrc = Math.floor((i - scaledMargin) / scale);\n                    var jSrc = Math.floor((j - scaledMargin) / scale);\n                    pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n                }\n                imgData[posDst++] = pxColor.r;\n                imgData[posDst++] = pxColor.g;\n                imgData[posDst++] = pxColor.b;\n                imgData[posDst] = pxColor.a;\n            }\n        }\n    };\n});\nvar canvas = createCommonjsModule(function (module, exports) {\n    function clearCanvas(ctx, canvas, size) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (!canvas.style)\n            canvas.style = {};\n        canvas.height = size;\n        canvas.width = size;\n        canvas.style.height = size + 'px';\n        canvas.style.width = size + 'px';\n    }\n    function getCanvasElement() {\n        try {\n            return document.createElement('canvas');\n        }\n        catch (e) {\n            throw new Error('You need to specify a canvas element');\n        }\n    }\n    exports.render = function render(qrData, canvas, options) {\n        var opts = options;\n        var canvasEl = canvas;\n        if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n            opts = canvas;\n            canvas = undefined;\n        }\n        if (!canvas) {\n            canvasEl = getCanvasElement();\n        }\n        opts = utils$1.getOptions(opts);\n        var size = utils$1.getImageWidth(qrData.modules.size, opts);\n        var ctx = canvasEl.getContext('2d');\n        var image = ctx.createImageData(size, size);\n        utils$1.qrToImageData(image.data, qrData, opts);\n        clearCanvas(ctx, canvasEl, size);\n        ctx.putImageData(image, 0, 0);\n        return canvasEl;\n    };\n    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n        var opts = options;\n        if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n            opts = canvas;\n            canvas = undefined;\n        }\n        if (!opts)\n            opts = {};\n        var canvasEl = exports.render(qrData, canvas, opts);\n        var type = opts.type || 'image/png';\n        var rendererOpts = opts.rendererOpts || {};\n        return canvasEl.toDataURL(type, rendererOpts.quality);\n    };\n});\nfunction getColorAttrib(color, attrib) {\n    var alpha = color.a / 255;\n    var str = attrib + '=\"' + color.hex + '\"';\n    return alpha < 1\n        ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n        : str;\n}\nfunction svgCmd(cmd, x, y) {\n    var str = cmd + x;\n    if (typeof y !== 'undefined')\n        str += ' ' + y;\n    return str;\n}\nfunction qrToPath(data, size, margin) {\n    var path = '';\n    var moveBy = 0;\n    var newRow = false;\n    var lineLength = 0;\n    for (var i = 0; i < data.length; i++) {\n        var col = Math.floor(i % size);\n        var row = Math.floor(i / size);\n        if (!col && !newRow)\n            newRow = true;\n        if (data[i]) {\n            lineLength++;\n            if (!(i > 0 && col > 0 && data[i - 1])) {\n                path += newRow\n                    ? svgCmd('M', col + margin, 0.5 + row + margin)\n                    : svgCmd('m', moveBy, 0);\n                moveBy = 0;\n                newRow = false;\n            }\n            if (!(col + 1 < size && data[i + 1])) {\n                path += svgCmd('h', lineLength);\n                lineLength = 0;\n            }\n        }\n        else {\n            moveBy++;\n        }\n    }\n    return path;\n}\nvar render = function render(qrData, options, cb) {\n    var opts = utils$1.getOptions(options);\n    var size = qrData.modules.size;\n    var data = qrData.modules.data;\n    var qrcodesize = size + opts.margin * 2;\n    var bg = !opts.color.light.a\n        ? ''\n        : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n            ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>';\n    var path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n        ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n    var viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"';\n    var width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n    var svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n';\n    if (typeof cb === 'function') {\n        cb(null, svgTag);\n    }\n    return svgTag;\n};\nvar svgTag = {\n    render: render\n};\nfunction renderCanvas(renderFunc, canvas, text, opts, cb) {\n    var args = [].slice.call(arguments, 1);\n    var argsNum = args.length;\n    var isLastArgCb = typeof args[argsNum - 1] === 'function';\n    if (!isLastArgCb && !canPromise()) {\n        throw new Error('Callback required as last argument');\n    }\n    if (isLastArgCb) {\n        if (argsNum < 2) {\n            throw new Error('Too few arguments provided');\n        }\n        if (argsNum === 2) {\n            cb = text;\n            text = canvas;\n            canvas = opts = undefined;\n        }\n        else if (argsNum === 3) {\n            if (canvas.getContext && typeof cb === 'undefined') {\n                cb = opts;\n                opts = undefined;\n            }\n            else {\n                cb = opts;\n                opts = text;\n                text = canvas;\n                canvas = undefined;\n            }\n        }\n    }\n    else {\n        if (argsNum < 1) {\n            throw new Error('Too few arguments provided');\n        }\n        if (argsNum === 1) {\n            text = canvas;\n            canvas = opts = undefined;\n        }\n        else if (argsNum === 2 && !canvas.getContext) {\n            opts = text;\n            text = canvas;\n            canvas = undefined;\n        }\n        return new Promise(function (resolve, reject) {\n            try {\n                var data = qrcode.create(text, opts);\n                resolve(renderFunc(data, canvas, opts));\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    try {\n        var data = qrcode.create(text, opts);\n        cb(null, renderFunc(data, canvas, opts));\n    }\n    catch (e) {\n        cb(e);\n    }\n}\nvar create$1 = qrcode.create;\nvar toCanvas = renderCanvas.bind(null, canvas.render);\nvar toDataURL = renderCanvas.bind(null, canvas.renderToDataURL);\n// only svg for now.\nvar toString_1 = renderCanvas.bind(null, function (data, _, opts) {\n    return svgTag.render(data, opts);\n});\nvar browser = {\n    create: create$1,\n    toCanvas: toCanvas,\n    toDataURL: toDataURL,\n    toString: toString_1\n};\nvar amplifyTotpSetupCss = \".totp-setup{text-align:center;margin-bottom:30px}.totp-setup img{height:128px;width:128px}\";\nvar logger = new Logger('TOTP');\nvar AmplifyTOTPSetup = /** @class */ (function () {\n    function class_1(hostRef) {\n        registerInstance(this, hostRef);\n        this.inputProps = {\n            autoFocus: true,\n        };\n        /** Auth state change handler for this component */\n        this.handleAuthStateChange = dispatchAuthStateChangeEvent;\n        /** Used for header text in totp setup component */\n        this.headerText = Translations.TOTP_HEADER_TEXT;\n        /** Used for customizing the issuer string in the qr code image */\n        this.issuer = Translations.TOTP_ISSUER;\n        this.code = null;\n        this.setupMessage = null;\n        this.qrCodeInput = null;\n        this.loading = false;\n    }\n    class_1.prototype.componentWillLoad = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        /**\n                         * We didn't use `@Watch` here because it doesn't fire when we go from require-new-password to totp-setup.\n                         * That is because `Auth.completeNewPassword` only changes `user` in place and Watch doesn't detect changes\n                         * unless we make a clone.\n                         */\n                        this.removeHubListener = onAuthUIStateChange(function (authState) {\n                            if (authState === AuthState.TOTPSetup)\n                                _this.setup();\n                        });\n                        return [4 /*yield*/, this.setup()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.disconnectedCallback = function () {\n        this.removeHubListener && this.removeHubListener(); // stop listening to `onAuthUIStateChange`\n    };\n    class_1.prototype.buildOtpAuthPath = function (user, issuer, secretKey) {\n        return \"otpauth://totp/\" + issuer + \":\" + user.username + \"?secret=\" + secretKey + \"&issuer=\" + issuer;\n    };\n    class_1.prototype.onTOTPEvent = function (event, data, user) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        logger.debug('on totp event', event, data);\n                        if (!(event === SETUP_TOTP && data === SUCCESS)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, checkContact(user, this.handleAuthStateChange)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.handleTotpInputChange = function (event) {\n        this.setupMessage = null;\n        this.qrCodeInput = event.target.value;\n    };\n    class_1.prototype.generateQRCode = function (codeFromTotp) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 2, , 3]);\n                        _a = this;\n                        return [4 /*yield*/, browser.toDataURL(codeFromTotp)];\n                    case 1:\n                        _a.qrCodeImageSource = _b.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _b.sent();\n                        dispatchToastHubEvent(error_1);\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.setup = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedIssuer, secretKey, error_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // ensure setup is only run once after totp setup is available\n                        if (!this.user || this.user.challengeName !== 'MFA_SETUP' || this.loading)\n                            return [2 /*return*/];\n                        this.setupMessage = null;\n                        encodedIssuer = encodeURI(I18n.get(this.issuer));\n                        if (!Auth || typeof Auth.setupTOTP !== 'function') {\n                            throw new Error(NO_AUTH_MODULE_FOUND);\n                        }\n                        this.loading = true;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        return [4 /*yield*/, Auth.setupTOTP(this.user)];\n                    case 2:\n                        secretKey = _a.sent();\n                        logger.debug('secret key', secretKey);\n                        this.code = this.buildOtpAuthPath(this.user, encodedIssuer, secretKey);\n                        this.generateQRCode(this.code);\n                        return [3 /*break*/, 5];\n                    case 3:\n                        error_2 = _a.sent();\n                        dispatchToastHubEvent(error_2);\n                        logger.debug(I18n.get(Translations.TOTP_SETUP_FAILURE), error_2);\n                        return [3 /*break*/, 5];\n                    case 4:\n                        this.loading = false;\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.verifyTotpToken = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var user, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (event) {\n                            event.preventDefault();\n                        }\n                        if (!this.qrCodeInput) {\n                            logger.debug('No TOTP Code provided');\n                            return [2 /*return*/];\n                        }\n                        user = this.user;\n                        if (!Auth || typeof Auth.verifyTotpToken !== 'function' || typeof Auth.setPreferredMFA !== 'function') {\n                            throw new Error(NO_AUTH_MODULE_FOUND);\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 5, , 6]);\n                        return [4 /*yield*/, Auth.verifyTotpToken(user, this.qrCodeInput)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, Auth.setPreferredMFA(user, MfaOption.TOTP)];\n                    case 3:\n                        _a.sent();\n                        this.setupMessage = I18n.get(Translations.TOTP_SUCCESS_MESSAGE);\n                        logger.debug(I18n.get(Translations.TOTP_SUCCESS_MESSAGE));\n                        return [4 /*yield*/, this.onTOTPEvent(SETUP_TOTP, SUCCESS, user)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 6];\n                    case 5:\n                        error_3 = _a.sent();\n                        this.setupMessage = I18n.get(Translations.TOTP_SETUP_FAILURE);\n                        logger.error(error_3);\n                        return [3 /*break*/, 6];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.render = function () {\n        var _this = this;\n        return (h(Host, null, h(\"amplify-form-section\", { headerText: I18n.get(this.headerText), submitButtonText: I18n.get(Translations.TOTP_SUBMIT_BUTTON_TEXT), handleSubmit: function (event) { return _this.verifyTotpToken(event); }, loading: this.loading }, h(\"div\", { class: \"totp-setup\" }, this.qrCodeImageSource && h(\"img\", { src: this.qrCodeImageSource, alt: I18n.get(Translations.QR_CODE_ALT) }), h(\"amplify-form-field\", { label: I18n.get(Translations.TOTP_LABEL), inputProps: this.inputProps, fieldId: \"totpCode\", name: \"totpCode\", handleInputChange: function (event) { return _this.handleTotpInputChange(event); } })))));\n    };\n    return class_1;\n}());\nAmplifyTOTPSetup.style = amplifyTotpSetupCss;\nexport { AmplifyRadioButton as amplify_radio_button, AmplifyTOTPSetup as amplify_totp_setup };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}