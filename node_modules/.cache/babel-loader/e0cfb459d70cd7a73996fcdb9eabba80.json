{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport keyMap from '../jsutils/keyMap';\nimport isInvalid from '../jsutils/isInvalid';\nimport objectValues from '../jsutils/objectValues';\nimport { Kind } from '../language/kinds';\nimport { isScalarType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n  if (valueNode.kind === Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n    if (!variables || isInvalid(variables[variableName])) {\n      // No valid return value.\n      return;\n    }\n    var variableValue = variables[variableName];\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n    return variableValue;\n  }\n  if (isListType(type)) {\n    var itemType = type.ofType;\n    if (valueNode.kind === Kind.LIST) {\n      var coercedValues = [];\n      var itemNodes = valueNode.values;\n      for (var i = 0; i < itemNodes.length; i++) {\n        if (isMissingVariable(itemNodes[i], variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNodes[i], itemType, variables);\n          if (isInvalid(itemValue)) {\n            return; // Invalid: intentionally return no value.\n          }\n          coercedValues.push(itemValue);\n        }\n      }\n      return coercedValues;\n    }\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n    if (isInvalid(coercedValue)) {\n      return; // Invalid: intentionally return no value.\n    }\n    return [coercedValue];\n  }\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n    var coercedObj = Object.create(null);\n    var fieldNodes = keyMap(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n    var fields = objectValues(type.getFields());\n    for (var _i = 0; _i < fields.length; _i++) {\n      var field = fields[_i];\n      var fieldNode = fieldNodes[field.name];\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n        continue;\n      }\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n      if (isInvalid(fieldValue)) {\n        return; // Invalid: intentionally return no value.\n      }\n      coercedObj[field.name] = fieldValue;\n    }\n    return coercedObj;\n  }\n  if (isEnumType(type)) {\n    if (valueNode.kind !== Kind.ENUM) {\n      return; // Invalid: intentionally return no value.\n    }\n    var enumValue = type.getValue(valueNode.value);\n    if (!enumValue) {\n      return; // Invalid: intentionally return no value.\n    }\n    return enumValue.value;\n  }\n  if (isScalarType(type)) {\n    // Scalars fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result;\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n    if (isInvalid(result)) {\n      return; // Invalid: intentionally return no value.\n    }\n    return result;\n  }\n  /* istanbul ignore next */\n\n  throw new Error(\"Unknown type: \".concat(type, \".\"));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (!variables || isInvalid(variables[valueNode.name.value]));\n}","map":{"version":3,"names":["keyMap","isInvalid","objectValues","Kind","isScalarType","isEnumType","isInputObjectType","isListType","isNonNullType","valueFromAST","valueNode","type","variables","kind","NULL","ofType","VARIABLE","variableName","name","value","variableValue","itemType","LIST","coercedValues","itemNodes","values","i","length","isMissingVariable","push","itemValue","coercedValue","OBJECT","coercedObj","Object","create","fieldNodes","fields","field","getFields","_i","fieldNode","defaultValue","undefined","fieldValue","ENUM","enumValue","getValue","result","parseLiteral","_error","Error","concat"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/utilities/valueFromAST.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport keyMap from '../jsutils/keyMap';\nimport isInvalid from '../jsutils/isInvalid';\nimport objectValues from '../jsutils/objectValues';\nimport { Kind } from '../language/kinds';\nimport { isScalarType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n\n    if (!variables || isInvalid(variables[variableName])) {\n      // No valid return value.\n      return;\n    }\n\n    var variableValue = variables[variableName];\n\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (valueNode.kind === Kind.LIST) {\n      var coercedValues = [];\n      var itemNodes = valueNode.values;\n\n      for (var i = 0; i < itemNodes.length; i++) {\n        if (isMissingVariable(itemNodes[i], variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNodes[i], itemType, variables);\n\n          if (isInvalid(itemValue)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (isInvalid(coercedValue)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var coercedObj = Object.create(null);\n    var fieldNodes = keyMap(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n    var fields = objectValues(type.getFields());\n\n    for (var _i = 0; _i < fields.length; _i++) {\n      var field = fields[_i];\n      var fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (isInvalid(fieldValue)) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if (isEnumType(type)) {\n    if (valueNode.kind !== Kind.ENUM) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var enumValue = type.getValue(valueNode.value);\n\n    if (!enumValue) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return enumValue.value;\n  }\n\n  if (isScalarType(type)) {\n    // Scalars fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (isInvalid(result)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Unknown type: \".concat(type, \".\"));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (!variables || isInvalid(variables[valueNode.name.value]));\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,MAAM,MAAM,mBAAmB;AACtC,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,SAASC,IAAI,QAAQ,mBAAmB;AACxC,SAASC,YAAY,EAAEC,UAAU,EAAEC,iBAAiB,EAAEC,UAAU,EAAEC,aAAa,QAAQ,oBAAoB;;AAE3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACC,SAAS,EAAEC,IAAI,EAAEC,SAAS,EAAE;EACvD,IAAI,CAACF,SAAS,EAAE;IACd;IACA;IACA;EACF;EAEA,IAAIF,aAAa,CAACG,IAAI,CAAC,EAAE;IACvB,IAAID,SAAS,CAACG,IAAI,KAAKV,IAAI,CAACW,IAAI,EAAE;MAChC,OAAO,CAAC;IACV;IAEA,OAAOL,YAAY,CAACC,SAAS,EAAEC,IAAI,CAACI,MAAM,EAAEH,SAAS,CAAC;EACxD;EAEA,IAAIF,SAAS,CAACG,IAAI,KAAKV,IAAI,CAACW,IAAI,EAAE;IAChC;IACA,OAAO,IAAI;EACb;EAEA,IAAIJ,SAAS,CAACG,IAAI,KAAKV,IAAI,CAACa,QAAQ,EAAE;IACpC,IAAIC,YAAY,GAAGP,SAAS,CAACQ,IAAI,CAACC,KAAK;IAEvC,IAAI,CAACP,SAAS,IAAIX,SAAS,CAACW,SAAS,CAACK,YAAY,CAAC,CAAC,EAAE;MACpD;MACA;IACF;IAEA,IAAIG,aAAa,GAAGR,SAAS,CAACK,YAAY,CAAC;IAE3C,IAAIG,aAAa,KAAK,IAAI,IAAIZ,aAAa,CAACG,IAAI,CAAC,EAAE;MACjD,OAAO,CAAC;IACV,CAAC,CAAC;IACF;IACA;;IAGA,OAAOS,aAAa;EACtB;EAEA,IAAIb,UAAU,CAACI,IAAI,CAAC,EAAE;IACpB,IAAIU,QAAQ,GAAGV,IAAI,CAACI,MAAM;IAE1B,IAAIL,SAAS,CAACG,IAAI,KAAKV,IAAI,CAACmB,IAAI,EAAE;MAChC,IAAIC,aAAa,GAAG,EAAE;MACtB,IAAIC,SAAS,GAAGd,SAAS,CAACe,MAAM;MAEhC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;QACzC,IAAIE,iBAAiB,CAACJ,SAAS,CAACE,CAAC,CAAC,EAAEd,SAAS,CAAC,EAAE;UAC9C;UACA;UACA,IAAIJ,aAAa,CAACa,QAAQ,CAAC,EAAE;YAC3B,OAAO,CAAC;UACV;UAEAE,aAAa,CAACM,IAAI,CAAC,IAAI,CAAC;QAC1B,CAAC,MAAM;UACL,IAAIC,SAAS,GAAGrB,YAAY,CAACe,SAAS,CAACE,CAAC,CAAC,EAAEL,QAAQ,EAAET,SAAS,CAAC;UAE/D,IAAIX,SAAS,CAAC6B,SAAS,CAAC,EAAE;YACxB,OAAO,CAAC;UACV;UAEAP,aAAa,CAACM,IAAI,CAACC,SAAS,CAAC;QAC/B;MACF;MAEA,OAAOP,aAAa;IACtB;IAEA,IAAIQ,YAAY,GAAGtB,YAAY,CAACC,SAAS,EAAEW,QAAQ,EAAET,SAAS,CAAC;IAE/D,IAAIX,SAAS,CAAC8B,YAAY,CAAC,EAAE;MAC3B,OAAO,CAAC;IACV;IAEA,OAAO,CAACA,YAAY,CAAC;EACvB;EAEA,IAAIzB,iBAAiB,CAACK,IAAI,CAAC,EAAE;IAC3B,IAAID,SAAS,CAACG,IAAI,KAAKV,IAAI,CAAC6B,MAAM,EAAE;MAClC,OAAO,CAAC;IACV;IAEA,IAAIC,UAAU,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;IACpC,IAAIC,UAAU,GAAGpC,MAAM,CAACU,SAAS,CAAC2B,MAAM,EAAE,UAAUC,KAAK,EAAE;MACzD,OAAOA,KAAK,CAACpB,IAAI,CAACC,KAAK;IACzB,CAAC,CAAC;IACF,IAAIkB,MAAM,GAAGnC,YAAY,CAACS,IAAI,CAAC4B,SAAS,CAAC,CAAC,CAAC;IAE3C,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGH,MAAM,CAACV,MAAM,EAAEa,EAAE,EAAE,EAAE;MACzC,IAAIF,KAAK,GAAGD,MAAM,CAACG,EAAE,CAAC;MACtB,IAAIC,SAAS,GAAGL,UAAU,CAACE,KAAK,CAACpB,IAAI,CAAC;MAEtC,IAAI,CAACuB,SAAS,IAAIb,iBAAiB,CAACa,SAAS,CAACtB,KAAK,EAAEP,SAAS,CAAC,EAAE;QAC/D,IAAI0B,KAAK,CAACI,YAAY,KAAKC,SAAS,EAAE;UACpCV,UAAU,CAACK,KAAK,CAACpB,IAAI,CAAC,GAAGoB,KAAK,CAACI,YAAY;QAC7C,CAAC,MAAM,IAAIlC,aAAa,CAAC8B,KAAK,CAAC3B,IAAI,CAAC,EAAE;UACpC,OAAO,CAAC;QACV;QAEA;MACF;MAEA,IAAIiC,UAAU,GAAGnC,YAAY,CAACgC,SAAS,CAACtB,KAAK,EAAEmB,KAAK,CAAC3B,IAAI,EAAEC,SAAS,CAAC;MAErE,IAAIX,SAAS,CAAC2C,UAAU,CAAC,EAAE;QACzB,OAAO,CAAC;MACV;MAEAX,UAAU,CAACK,KAAK,CAACpB,IAAI,CAAC,GAAG0B,UAAU;IACrC;IAEA,OAAOX,UAAU;EACnB;EAEA,IAAI5B,UAAU,CAACM,IAAI,CAAC,EAAE;IACpB,IAAID,SAAS,CAACG,IAAI,KAAKV,IAAI,CAAC0C,IAAI,EAAE;MAChC,OAAO,CAAC;IACV;IAEA,IAAIC,SAAS,GAAGnC,IAAI,CAACoC,QAAQ,CAACrC,SAAS,CAACS,KAAK,CAAC;IAE9C,IAAI,CAAC2B,SAAS,EAAE;MACd,OAAO,CAAC;IACV;IAEA,OAAOA,SAAS,CAAC3B,KAAK;EACxB;EAEA,IAAIf,YAAY,CAACO,IAAI,CAAC,EAAE;IACtB;IACA;IACA;IACA,IAAIqC,MAAM;IAEV,IAAI;MACFA,MAAM,GAAGrC,IAAI,CAACsC,YAAY,CAACvC,SAAS,EAAEE,SAAS,CAAC;IAClD,CAAC,CAAC,OAAOsC,MAAM,EAAE;MACf,OAAO,CAAC;IACV;IAEA,IAAIjD,SAAS,CAAC+C,MAAM,CAAC,EAAE;MACrB,OAAO,CAAC;IACV;IAEA,OAAOA,MAAM;EACf;EACA;;EAGA,MAAM,IAAIG,KAAK,CAAC,gBAAgB,CAACC,MAAM,CAACzC,IAAI,EAAE,GAAG,CAAC,CAAC;AACrD,CAAC,CAAC;AACF;;AAEA,SAASiB,iBAAiBA,CAAClB,SAAS,EAAEE,SAAS,EAAE;EAC/C,OAAOF,SAAS,CAACG,IAAI,KAAKV,IAAI,CAACa,QAAQ,KAAK,CAACJ,SAAS,IAAIX,SAAS,CAACW,SAAS,CAACF,SAAS,CAACQ,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC;AACvG","ignoreList":[]},"metadata":{},"sourceType":"module"}