{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isInputType, isOutputType, isRequiredArgument } from './definition';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\nimport inspect from '../jsutils/inspect';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, \"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\")) : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\nvar SchemaValidationContext = /*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    _defineProperty(this, \"_errors\", void 0);\n    _defineProperty(this, \"schema\", void 0);\n    this._errors = [];\n    this.schema = schema;\n  }\n  var _proto = SchemaValidationContext.prototype;\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n    this.addError(new GraphQLError(message, _nodes));\n  };\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n  return SchemaValidationContext;\n}();\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n  var mutationType = schema.getMutationType();\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n  var subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n      if (node.operation === operation) {\n        return node.type;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  return type.astNode;\n}\nfunction validateDirectives(context) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n  try {\n    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value;\n\n      // Ensure all directives are in fact GraphQL directives.\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n      try {\n        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var arg = _step3.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per directive.\n\n          if (argNames[argName]) {\n            context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), getAllDirectiveArgNodes(directive, argName));\n            continue;\n          }\n          argNames[argName] = true; // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), getDirectiveArgTypeNode(directive, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n  if (error) {\n    context.addError(error);\n  }\n}\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n  try {\n    for (var _iterator4 = objectValues(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var type = _step4.value;\n\n      // Ensure all provided types are in fact GraphQL type.\n      if (!isNamedType(type)) {\n        context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n        continue;\n      } // Ensure it is named correctly (excluding introspection types).\n\n      if (!isIntrospectionType(type)) {\n        validateName(context, type);\n      }\n      if (isObjectType(type)) {\n        // Ensure fields are valid\n        validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n        validateObjectInterfaces(context, type);\n      } else if (isInterfaceType(type)) {\n        // Ensure fields are valid.\n        validateFields(context, type);\n      } else if (isUnionType(type)) {\n        // Ensure Unions include valid member types.\n        validateUnionMembers(context, type);\n      } else if (isEnumType(type)) {\n        // Ensure Enums have valid values.\n        validateEnumValues(context, type);\n      } else if (isInputObjectType(type)) {\n        // Ensure Input Object fields are valid.\n        validateInputFields(context, type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n  try {\n    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // Ensure they were defined at most once.\n\n      var fieldNodes = getAllFieldNodes(type, field.name);\n      if (fieldNodes.length > 1) {\n        context.reportError(\"Field \".concat(type.name, \".\").concat(field.name, \" can only be defined once.\"), fieldNodes);\n        continue;\n      } // Ensure the type is an output type\n\n      if (!isOutputType(field.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), getFieldTypeNode(type, field.name));\n      } // Ensure the arguments are valid\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n      try {\n        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var arg = _step6.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per field.\n\n          if (argNames[argName]) {\n            context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only \") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n          }\n          argNames[argName] = true; // Ensure the type is an input type\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), getFieldArgTypeNode(type, field.name, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n  try {\n    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var iface = _step7.value;\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getImplementsInterfaceNode(object, iface));\n        continue;\n      }\n      if (implementedTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n        continue;\n      }\n      implementedTypeNames[iface.name] = true;\n      validateObjectImplementsInterface(context, object, iface);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  var _arr = Object.keys(ifaceFieldMap);\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fieldName = _arr[_i];\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \") + \"\".concat(object.name, \" does not provide it.\"), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step8.value;\n        var argName = ifaceArg.name;\n        var objectArg = find(objectField.args, function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!objectArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expected but \".concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n        if (!isEqualType(ifaceArg.type, objectArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n        } // TODO: validate default values?\n      };\n      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _ret = _loop();\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n    try {\n      var _loop2 = function _loop2() {\n        var objectArg = _step9.value;\n        var argName = objectArg.name;\n        var ifaceArg = find(ifaceField.args, function (arg) {\n          return arg.name === argName;\n        });\n        if (!ifaceArg && isRequiredArgument(objectArg)) {\n          context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required \") + \"argument \".concat(argName, \" that is missing from the Interface field \") + \"\".concat(iface.name, \".\").concat(fieldName, \".\"), [getFieldArgNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n        }\n      };\n      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        _loop2();\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  }\n}\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n  var includedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n  try {\n    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var memberType = _step10.value;\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \") + \"\".concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n      includedTypeNames[memberType.name] = true;\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n  try {\n    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var enumValue = _step11.value;\n      var valueName = enumValue.name; // Ensure no duplicates.\n\n      var allNodes = getEnumValueNodes(enumType, valueName);\n      if (allNodes && allNodes.length > 1) {\n        context.reportError(\"Enum type \".concat(enumType.name, \" can include value \").concat(valueName, \" only once.\"), allNodes);\n      } // Ensure valid name.\n\n      validateName(context, enumValue);\n      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n        context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n  try {\n    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var field = _step12.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // TODO: Ensure they are unique per field.\n      // Ensure the type is an input type\n\n      if (!isInputType(field.type)) {\n        context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n}\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n    extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\nfunction getAllSubNodes(object, getter) {\n  var result = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n  try {\n    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var astNode = _step13.value;\n      if (astNode) {\n        var subNodes = getter(astNode);\n        if (subNodes) {\n          result = result.concat(subNodes);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n  return result;\n}\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\nfunction getAllFieldNodes(type, fieldName) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.fields;\n  }).filter(function (fieldNode) {\n    return fieldNode.name.value === fieldName;\n  });\n}\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n  if (fieldNode && fieldNode.arguments) {\n    var _iteratorNormalCompletion14 = true;\n    var _didIteratorError14 = false;\n    var _iteratorError14 = undefined;\n    try {\n      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n        var node = _step14.value;\n        if (node.name.value === argName) {\n          argNodes.push(node);\n        }\n      }\n    } catch (err) {\n      _didIteratorError14 = true;\n      _iteratorError14 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n          _iterator14.return();\n        }\n      } finally {\n        if (_didIteratorError14) {\n          throw _iteratorError14;\n        }\n      }\n    }\n  }\n  return argNodes;\n}\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\nfunction getAllDirectiveArgNodes(directive, argName) {\n  return getAllSubNodes(directive, function (directiveNode) {\n    return directiveNode.arguments;\n  }).filter(function (argNode) {\n    return argNode.name.value === argName;\n  });\n}\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\nfunction getEnumValueNodes(enumType, valueName) {\n  return getAllSubNodes(enumType, function (enumNode) {\n    return enumNode.values;\n  }).filter(function (valueNode) {\n    return valueNode.name.value === valueName;\n  });\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isInputType","isOutputType","isRequiredArgument","isDirective","isIntrospectionType","isSchema","inspect","find","invariant","objectValues","GraphQLError","isValidNameError","isEqualType","isTypeSubTypeOf","validateSchema","schema","concat","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","getOperationTypeNode","mutationType","getMutationType","subscriptionType","getSubscriptionType","type","operation","operationNodes","getAllSubNodes","node","operationTypes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","getDirectives","_step2","directive","validateName","argNames","create","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","args","_step3","arg","argName","name","getAllDirectiveArgNodes","getDirectiveArgTypeNode","__allowedLegacyNames","indexOf","typeMap","getTypeMap","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","validateFields","validateObjectInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","field","fieldNodes","getAllFieldNodes","getFieldTypeNode","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","getAllFieldArgNodes","getFieldArgTypeNode","object","implementedTypeNames","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","getInterfaces","_step7","iface","getImplementsInterfaceNode","getAllImplementsInterfaceNodes","validateObjectImplementsInterface","objectFieldMap","ifaceFieldMap","_arr","keys","_i","fieldName","objectField","ifaceField","getFieldNode","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_loop","ifaceArg","_step8","objectArg","getFieldArgNode","_iterator8","_ret","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_loop2","_step9","_iterator9","union","memberTypes","getTypes","includedTypeNames","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_iterator11","_step11","enumValue","valueName","allNodes","getEnumValueNodes","inputObj","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","extensionASTNodes","getter","result","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","_step13","subNodes","typeNode","interfaces","ifaceNode","fieldNode","argNodes","arguments","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_iterator14","_step14","fieldArgNode","directiveNode","argNode","typeName","unionNode","types","enumNode","values","valueNode"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/type/validate.mjs"],"sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isInputType, isOutputType, isRequiredArgument } from './definition';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\nimport inspect from '../jsutils/inspect';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, \"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\")) : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext =\n/*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    _defineProperty(this, \"_errors\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n\n      if (node.operation === operation) {\n        return node.type;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value;\n\n      // Ensure all directives are in fact GraphQL directives.\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var arg = _step3.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per directive.\n\n          if (argNames[argName]) {\n            context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), getAllDirectiveArgNodes(directive, argName));\n            continue;\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), getDirectiveArgTypeNode(directive, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = objectValues(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var type = _step4.value;\n\n      // Ensure all provided types are in fact GraphQL type.\n      if (!isNamedType(type)) {\n        context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n        continue;\n      } // Ensure it is named correctly (excluding introspection types).\n\n\n      if (!isIntrospectionType(type)) {\n        validateName(context, type);\n      }\n\n      if (isObjectType(type)) {\n        // Ensure fields are valid\n        validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n        validateObjectInterfaces(context, type);\n      } else if (isInterfaceType(type)) {\n        // Ensure fields are valid.\n        validateFields(context, type);\n      } else if (isUnionType(type)) {\n        // Ensure Unions include valid member types.\n        validateUnionMembers(context, type);\n      } else if (isEnumType(type)) {\n        // Ensure Enums have valid values.\n        validateEnumValues(context, type);\n      } else if (isInputObjectType(type)) {\n        // Ensure Input Object fields are valid.\n        validateInputFields(context, type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // Ensure they were defined at most once.\n\n      var fieldNodes = getAllFieldNodes(type, field.name);\n\n      if (fieldNodes.length > 1) {\n        context.reportError(\"Field \".concat(type.name, \".\").concat(field.name, \" can only be defined once.\"), fieldNodes);\n        continue;\n      } // Ensure the type is an output type\n\n\n      if (!isOutputType(field.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), getFieldTypeNode(type, field.name));\n      } // Ensure the arguments are valid\n\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var arg = _step6.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per field.\n\n          if (argNames[argName]) {\n            context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only \") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), getFieldArgTypeNode(type, field.name, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var iface = _step7.value;\n\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getImplementsInterfaceNode(object, iface));\n        continue;\n      }\n\n      if (implementedTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n        continue;\n      }\n\n      implementedTypeNames[iface.name] = true;\n      validateObjectImplementsInterface(context, object, iface);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  var _arr = Object.keys(ifaceFieldMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fieldName = _arr[_i];\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \") + \"\".concat(object.name, \" does not provide it.\"), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step8.value;\n        var argName = ifaceArg.name;\n        var objectArg = find(objectField.args, function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!objectArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expected but \".concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n\n        if (!isEqualType(ifaceArg.type, objectArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n        } // TODO: validate default values?\n\n      };\n\n      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      var _loop2 = function _loop2() {\n        var objectArg = _step9.value;\n        var argName = objectArg.name;\n        var ifaceArg = find(ifaceField.args, function (arg) {\n          return arg.name === argName;\n        });\n\n        if (!ifaceArg && isRequiredArgument(objectArg)) {\n          context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required \") + \"argument \".concat(argName, \" that is missing from the Interface field \") + \"\".concat(iface.name, \".\").concat(fieldName, \".\"), [getFieldArgNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n        }\n      };\n\n      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        _loop2();\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var memberType = _step10.value;\n\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \") + \"\".concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n\n      includedTypeNames[memberType.name] = true;\n\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var enumValue = _step11.value;\n      var valueName = enumValue.name; // Ensure no duplicates.\n\n      var allNodes = getEnumValueNodes(enumType, valueName);\n\n      if (allNodes && allNodes.length > 1) {\n        context.reportError(\"Enum type \".concat(enumType.name, \" can include value \").concat(valueName, \" only once.\"), allNodes);\n      } // Ensure valid name.\n\n\n      validateName(context, enumValue);\n\n      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n        context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var field = _step12.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // TODO: Ensure they are unique per field.\n      // Ensure the type is an input type\n\n      if (!isInputType(field.type)) {\n        context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var result = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var astNode = _step13.value;\n\n      if (astNode) {\n        var subNodes = getter(astNode);\n\n        if (subNodes) {\n          result = result.concat(subNodes);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.fields;\n  }).filter(function (fieldNode) {\n    return fieldNode.name.value === fieldName;\n  });\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n\n  if (fieldNode && fieldNode.arguments) {\n    var _iteratorNormalCompletion14 = true;\n    var _didIteratorError14 = false;\n    var _iteratorError14 = undefined;\n\n    try {\n      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n        var node = _step14.value;\n\n        if (node.name.value === argName) {\n          argNodes.push(node);\n        }\n      }\n    } catch (err) {\n      _didIteratorError14 = true;\n      _iteratorError14 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n          _iterator14.return();\n        }\n      } finally {\n        if (_didIteratorError14) {\n          throw _iteratorError14;\n        }\n      }\n    }\n  }\n\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  return getAllSubNodes(directive, function (directiveNode) {\n    return directiveNode.arguments;\n  }).filter(function (argNode) {\n    return argNode.name.value === argName;\n  });\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return getAllSubNodes(enumType, function (enumNode) {\n    return enumNode.values;\n  }).filter(function (valueNode) {\n    return valueNode.name.value === valueName;\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}