{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { visit } from '../language/visitor';\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var fragments = Object.create(null);\n  var positions = new Map();\n  var depGraph = Object.create(null);\n  var fromName;\n  var idx = 0; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n      positions.set(node, idx++);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n      fragments[fromName] = node;\n      positions.set(node, idx++);\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n  for (var _i = 0; _i < operations.length; _i++) {\n    var operation = operations[_i];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    var definitions = [operation];\n    var _arr = Object.keys(dependencies);\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var name = _arr[_i2];\n      definitions.push(fragments[name]);\n    }\n    definitions.sort(function (n1, n2) {\n      return (positions.get(n1) || 0) - (positions.get(n2) || 0);\n    });\n    separatedDocumentASTs[operationName] = {\n      kind: 'Document',\n      definitions: definitions\n    };\n  }\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n  if (immediateDeps) {\n    var _arr2 = Object.keys(immediateDeps);\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var toName = _arr2[_i3];\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}","map":{"version":3,"names":["visit","separateOperations","documentAST","operations","fragments","Object","create","positions","Map","depGraph","fromName","idx","OperationDefinition","node","opName","push","set","FragmentDefinition","name","value","FragmentSpread","toName","separatedDocumentASTs","_i","length","operation","operationName","dependencies","collectTransitiveDependencies","definitions","_arr","keys","_i2","sort","n1","n2","get","kind","collected","immediateDeps","_arr2","_i3"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { visit } from '../language/visitor';\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var fragments = Object.create(null);\n  var positions = new Map();\n  var depGraph = Object.create(null);\n  var fromName;\n  var idx = 0; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n      positions.set(node, idx++);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n      fragments[fromName] = node;\n      positions.set(node, idx++);\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  for (var _i = 0; _i < operations.length; _i++) {\n    var operation = operations[_i];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    var definitions = [operation];\n\n    var _arr = Object.keys(dependencies);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var name = _arr[_i2];\n      definitions.push(fragments[name]);\n    }\n\n    definitions.sort(function (n1, n2) {\n      return (positions.get(n1) || 0) - (positions.get(n2) || 0);\n    });\n    separatedDocumentASTs[operationName] = {\n      kind: 'Document',\n      definitions: definitions\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    var _arr2 = Object.keys(immediateDeps);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var toName = _arr2[_i3];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}