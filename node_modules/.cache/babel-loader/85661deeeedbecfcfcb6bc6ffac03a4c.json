{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules';\nimport { SDLValidationContext, ValidationContext } from './ValidationContext';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  !documentAST ? invariant(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var context = new ValidationContext(schema, documentAST, typeInfo); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  return context.getErrors();\n} // @internal\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var context = new SDLValidationContext(documentAST, schemaToExtend);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return context.getErrors();\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}","map":{"version":3,"names":["invariant","visit","visitInParallel","visitWithTypeInfo","assertValidSchema","TypeInfo","specifiedRules","specifiedSDLRules","SDLValidationContext","ValidationContext","validate","schema","documentAST","rules","arguments","length","undefined","typeInfo","context","visitor","map","rule","getErrors","validateSDL","schemaToExtend","visitors","assertValidSDL","errors","Error","error","message","join","assertValidSDLExtension"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/validation/validate.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules';\nimport { SDLValidationContext, ValidationContext } from './ValidationContext';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  !documentAST ? invariant(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var context = new ValidationContext(schema, documentAST, typeInfo); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  return context.getErrors();\n} // @internal\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var context = new SDLValidationContext(documentAST, schemaToExtend);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return context.getErrors();\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}