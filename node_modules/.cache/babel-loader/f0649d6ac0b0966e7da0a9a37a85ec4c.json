{"ast":null,"code":"/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from '../type/definition';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED'\n};\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return findRemovedTypes(oldSchema, newSchema).concat(findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return findArgChanges(oldSchema, newSchema).dangerousChanges.concat(findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var _arr = Object.keys(oldTypeMap);\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var typeName = _arr[_i];\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: \"\".concat(typeName, \" was removed.\")\n      });\n    }\n  }\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var _arr2 = Object.keys(oldTypeMap);\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var typeName = _arr2[_i2];\n    if (!newTypeMap[typeName]) {\n      continue;\n    }\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(typeName, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  var _arr3 = Object.keys(oldTypeMap);\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var typeName = _arr3[_i3];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n    var _arr4 = Object.keys(oldTypeFields);\n    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n      var fieldName = _arr4[_i4];\n      if (!newTypeFields[fieldName]) {\n        continue;\n      }\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        var _loop = function _loop() {\n          var oldArgDef = _step.value;\n          var newArgs = newTypeFields[fieldName].args;\n          var newArgDef = newArgs.find(function (arg) {\n            return arg.name === oldArgDef.name;\n          }); // Arg not present\n\n          if (!newArgDef) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_REMOVED,\n              description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" was removed\")\n            });\n          } else {\n            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n            if (!isSafe) {\n              breakingChanges.push({\n                type: BreakingChangeType.ARG_CHANGED_KIND,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed type from \") + \"\".concat(oldArgDef.type.toString(), \" to \").concat(newArgDef.type.toString())\n              });\n            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n              dangerousChanges.push({\n                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed defaultValue\")\n              });\n            }\n          }\n        };\n        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Check if arg was added to the field\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        var _loop2 = function _loop2() {\n          var newArgDef = _step2.value;\n          var oldArgs = oldTypeFields[fieldName].args;\n          var oldArgDef = oldArgs.find(function (arg) {\n            return arg.name === newArgDef.name;\n          });\n          if (!oldArgDef) {\n            var argName = newArgDef.name;\n            if (isRequiredArgument(newArgDef)) {\n              breakingChanges.push({\n                type: BreakingChangeType.REQUIRED_ARG_ADDED,\n                description: \"A required arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            } else {\n              dangerousChanges.push({\n                type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n                description: \"An optional arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            }\n          }\n        };\n        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var _arr5 = Object.keys(oldTypeMap);\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var typeName = _arr5[_i5];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    var _arr6 = Object.keys(oldTypeFieldsDef);\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var fieldName = _arr6[_i6];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    }\n  }\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  var _arr7 = Object.keys(oldTypeMap);\n  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n    var typeName = _arr7[_i7];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      continue;\n    }\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    var _arr8 = Object.keys(oldTypeFieldsDef);\n    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n      var fieldName = _arr8[_i8];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    } // Check if a field was added to the input object type\n\n    var _arr9 = Object.keys(newTypeFieldsDef);\n    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n      var _fieldName = _arr9[_i9];\n      if (!(_fieldName in oldTypeFieldsDef)) {\n        if (isRequiredInputField(newTypeFieldsDef[_fieldName])) {\n          breakingChanges.push({\n            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n            description: \"A required field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n            description: \"An optional field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        }\n      }\n    }\n  }\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (\n      // if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name ||\n      // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) ||\n      // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n  return false;\n}\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) ||\n      // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n  var _arr10 = Object.keys(oldTypeMap);\n  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n    var typeName = _arr10[_i10];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n    var typeNamesInNewUnion = Object.create(null);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n    try {\n      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var type = _step3.value;\n        typeNamesInNewUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n    try {\n      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _type = _step4.value;\n        if (!typeNamesInNewUnion[_type.name]) {\n          typesRemovedFromUnion.push({\n            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n            description: \"\".concat(_type.name, \" was removed from union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n  var _arr11 = Object.keys(newTypeMap);\n  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n    var typeName = _arr11[_i11];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n    var typeNamesInOldUnion = Object.create(null);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n    try {\n      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var type = _step5.value;\n        typeNamesInOldUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n    try {\n      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _type2 = _step6.value;\n        if (!typeNamesInOldUnion[_type2.name]) {\n          typesAddedToUnion.push({\n            type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n            description: \"\".concat(_type2.name, \" was added to union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n  var _arr12 = Object.keys(oldTypeMap);\n  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n    var typeName = _arr12[_i12];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n    var valuesInNewEnum = Object.create(null);\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n    try {\n      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var value = _step7.value;\n        valuesInNewEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n    try {\n      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _value = _step8.value;\n        if (!valuesInNewEnum[_value.name]) {\n          valuesRemovedFromEnums.push({\n            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n            description: \"\".concat(_value.name, \" was removed from enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n  var _arr13 = Object.keys(oldTypeMap);\n  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n    var typeName = _arr13[_i13];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n    var valuesInOldEnum = Object.create(null);\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n    try {\n      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n        valuesInOldEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n    try {\n      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _value2 = _step10.value;\n        if (!valuesInOldEnum[_value2.name]) {\n          valuesAddedToEnums.push({\n            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n            description: \"\".concat(_value2.name, \" was added to enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n  }\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var _arr14 = Object.keys(oldTypeMap);\n  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {\n    var typeName = _arr14[_i14];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n    try {\n      var _loop3 = function _loop3() {\n        var oldInterface = _step11.value;\n        if (!newInterfaces.some(function (int) {\n          return int.name === oldInterface.name;\n        })) {\n          breakingChanges.push({\n            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n            description: \"\".concat(typeName, \" no longer implements interface \") + \"\".concat(oldInterface.name, \".\")\n          });\n        }\n      };\n      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        _loop3();\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n  var _arr15 = Object.keys(newTypeMap);\n  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {\n    var typeName = _arr15[_i15];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n    try {\n      var _loop4 = function _loop4() {\n        var newInterface = _step12.value;\n        if (!oldInterfaces.some(function (int) {\n          return int.name === newInterface.name;\n        })) {\n          interfacesAddedToObjectTypes.push({\n            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n            description: \"\".concat(newInterface.name, \" added to interfaces implemented \") + \"by \".concat(typeName, \".\")\n          });\n        }\n      };\n      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        _loop4();\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  }\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n  try {\n    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var directive = _step13.value;\n      if (!newSchemaDirectiveMap[directive.name]) {\n        removedDirectives.push({\n          type: BreakingChangeType.DIRECTIVE_REMOVED,\n          description: \"\".concat(directive.name, \" was removed\")\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n  return removedDirectives;\n}\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n  try {\n    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var arg = _step14.value;\n      if (!newArgMap[arg.name]) {\n        removedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n  return removedArgs;\n}\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion15 = true;\n  var _didIteratorError15 = false;\n  var _iteratorError15 = undefined;\n  try {\n    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n      var newDirective = _step15.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n      if (!oldDirective) {\n        continue;\n      }\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n      try {\n        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var arg = _step16.value;\n          removedDirectiveArgs.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(arg.name, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError15 = true;\n    _iteratorError15 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n        _iterator15.return();\n      }\n    } finally {\n      if (_didIteratorError15) {\n        throw _iteratorError15;\n      }\n    }\n  }\n  return removedDirectiveArgs;\n}\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n  try {\n    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var arg = _step17.value;\n      if (!oldArgMap[arg.name]) {\n        addedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n  return addedArgs;\n}\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion18 = true;\n  var _didIteratorError18 = false;\n  var _iteratorError18 = undefined;\n  try {\n    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n      var newDirective = _step18.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n      if (!oldDirective) {\n        continue;\n      }\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n      try {\n        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var arg = _step19.value;\n          if (isRequiredArgument(arg)) {\n            addedNonNullableArgs.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(arg.name, \" on directive \") + \"\".concat(newDirective.name, \" was added\")\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError18 = true;\n    _iteratorError18 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n        _iterator18.return();\n      }\n    } finally {\n      if (_didIteratorError18) {\n        throw _iteratorError18;\n      }\n    }\n  }\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  var _iteratorNormalCompletion20 = true;\n  var _didIteratorError20 = false;\n  var _iteratorError20 = undefined;\n  try {\n    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n      var oldLocation = _step20.value;\n      if (!newLocationSet.has(oldLocation)) {\n        removedLocations.push(oldLocation);\n      }\n    }\n  } catch (err) {\n    _didIteratorError20 = true;\n    _iteratorError20 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n        _iterator20.return();\n      }\n    } finally {\n      if (_didIteratorError20) {\n        throw _iteratorError20;\n      }\n    }\n  }\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion21 = true;\n  var _didIteratorError21 = false;\n  var _iteratorError21 = undefined;\n  try {\n    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n      var newDirective = _step21.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n      if (!oldDirective) {\n        continue;\n      }\n      var _iteratorNormalCompletion22 = true;\n      var _didIteratorError22 = false;\n      var _iteratorError22 = undefined;\n      try {\n        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n          var location = _step22.value;\n          removedLocations.push({\n            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n            description: \"\".concat(location, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError22 = true;\n        _iteratorError22 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n            _iterator22.return();\n          }\n        } finally {\n          if (_didIteratorError22) {\n            throw _iteratorError22;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError21 = true;\n    _iteratorError21 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n        _iterator21.return();\n      }\n    } finally {\n      if (_didIteratorError21) {\n        throw _iteratorError21;\n      }\n    }\n  }\n  return removedLocations;\n}\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}","map":{"version":3,"names":["isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNonNullType","isListType","isNamedType","isRequiredArgument","isRequiredInputField","keyMap","BreakingChangeType","FIELD_CHANGED_KIND","FIELD_REMOVED","TYPE_CHANGED_KIND","TYPE_REMOVED","TYPE_REMOVED_FROM_UNION","VALUE_REMOVED_FROM_ENUM","ARG_REMOVED","ARG_CHANGED_KIND","REQUIRED_ARG_ADDED","REQUIRED_INPUT_FIELD_ADDED","INTERFACE_REMOVED_FROM_OBJECT","DIRECTIVE_REMOVED","DIRECTIVE_ARG_REMOVED","DIRECTIVE_LOCATION_REMOVED","REQUIRED_DIRECTIVE_ARG_ADDED","DangerousChangeType","ARG_DEFAULT_VALUE_CHANGE","VALUE_ADDED_TO_ENUM","INTERFACE_ADDED_TO_OBJECT","TYPE_ADDED_TO_UNION","OPTIONAL_INPUT_FIELD_ADDED","OPTIONAL_ARG_ADDED","findBreakingChanges","oldSchema","newSchema","findRemovedTypes","concat","findTypesThatChangedKind","findFieldsThatChangedTypeOnObjectOrInterfaceTypes","findFieldsThatChangedTypeOnInputObjectTypes","breakingChanges","findTypesRemovedFromUnions","findValuesRemovedFromEnums","findArgChanges","findInterfacesRemovedFromObjectTypes","findRemovedDirectives","findRemovedDirectiveArgs","findAddedNonNullDirectiveArgs","findRemovedDirectiveLocations","findDangerousChanges","dangerousChanges","findValuesAddedToEnums","findInterfacesAddedToObjectTypes","findTypesAddedToUnions","oldTypeMap","getTypeMap","newTypeMap","_arr","Object","keys","_i","length","typeName","push","type","description","_arr2","_i2","oldType","newType","constructor","typeKindName","_arr3","_i3","oldTypeFields","getFields","newTypeFields","_arr4","_i4","fieldName","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_loop","oldArgDef","_step","value","newArgs","args","newArgDef","find","arg","name","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","toString","defaultValue","_iterator","Symbol","iterator","next","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_loop2","_step2","oldArgs","argName","_iterator2","TypeError","_arr5","_i5","oldTypeFieldsDef","newTypeFieldsDef","_arr6","_i6","oldFieldType","newFieldType","isChangeSafeForObjectOrInterfaceField","oldFieldTypeString","newFieldTypeString","_arr7","_i7","_arr8","_i8","_arr9","_i9","_fieldName","ofType","typesRemovedFromUnion","_arr10","_i10","typeNamesInNewUnion","create","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","getTypes","_step3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_type","typesAddedToUnion","_arr11","_i11","typeNamesInOldUnion","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_type2","valuesRemovedFromEnums","_arr12","_i12","valuesInNewEnum","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","getValues","_step7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","_value","valuesAddedToEnums","_arr13","_i13","valuesInOldEnum","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","_value2","_arr14","_i14","oldInterfaces","getInterfaces","newInterfaces","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_loop3","oldInterface","_step11","some","int","_iterator11","interfacesAddedToObjectTypes","_arr15","_i15","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_loop4","newInterface","_step12","_iterator12","removedDirectives","newSchemaDirectiveMap","getDirectiveMapForSchema","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","getDirectives","_step13","directive","findRemovedArgsForDirective","oldDirective","newDirective","removedArgs","newArgMap","getArgumentMapForDirective","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_iterator14","_step14","removedDirectiveArgs","oldSchemaDirectiveMap","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_iterator15","_step15","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_iterator16","_step16","findAddedArgsForDirective","addedArgs","oldArgMap","_iteratorNormalCompletion17","_didIteratorError17","_iteratorError17","_iterator17","_step17","addedNonNullableArgs","_iteratorNormalCompletion18","_didIteratorError18","_iteratorError18","_iterator18","_step18","_iteratorNormalCompletion19","_didIteratorError19","_iteratorError19","_iterator19","_step19","findRemovedLocationsForDirective","removedLocations","newLocationSet","Set","locations","_iteratorNormalCompletion20","_didIteratorError20","_iteratorError20","_iterator20","_step20","oldLocation","has","_iteratorNormalCompletion21","_didIteratorError21","_iteratorError21","_iterator21","_step21","_iteratorNormalCompletion22","_didIteratorError22","_iteratorError22","_iterator22","_step22","location","schema","dir"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/utilities/findBreakingChanges.mjs"],"sourcesContent":["/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from '../type/definition';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED'\n};\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return findRemovedTypes(oldSchema, newSchema).concat(findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return findArgChanges(oldSchema, newSchema).dangerousChanges.concat(findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr = Object.keys(oldTypeMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var typeName = _arr[_i];\n\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: \"\".concat(typeName, \" was removed.\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr2 = Object.keys(oldTypeMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var typeName = _arr2[_i2];\n\n    if (!newTypeMap[typeName]) {\n      continue;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(typeName, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr3 = Object.keys(oldTypeMap);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var typeName = _arr3[_i3];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    var _arr4 = Object.keys(oldTypeFields);\n\n    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n      var fieldName = _arr4[_i4];\n\n      if (!newTypeFields[fieldName]) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var oldArgDef = _step.value;\n          var newArgs = newTypeFields[fieldName].args;\n          var newArgDef = newArgs.find(function (arg) {\n            return arg.name === oldArgDef.name;\n          }); // Arg not present\n\n          if (!newArgDef) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_REMOVED,\n              description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" was removed\")\n            });\n          } else {\n            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n            if (!isSafe) {\n              breakingChanges.push({\n                type: BreakingChangeType.ARG_CHANGED_KIND,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed type from \") + \"\".concat(oldArgDef.type.toString(), \" to \").concat(newArgDef.type.toString())\n              });\n            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n              dangerousChanges.push({\n                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed defaultValue\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Check if arg was added to the field\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop2 = function _loop2() {\n          var newArgDef = _step2.value;\n          var oldArgs = oldTypeFields[fieldName].args;\n          var oldArgDef = oldArgs.find(function (arg) {\n            return arg.name === newArgDef.name;\n          });\n\n          if (!oldArgDef) {\n            var argName = newArgDef.name;\n\n            if (isRequiredArgument(newArgDef)) {\n              breakingChanges.push({\n                type: BreakingChangeType.REQUIRED_ARG_ADDED,\n                description: \"A required arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            } else {\n              dangerousChanges.push({\n                type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n                description: \"An optional arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr5 = Object.keys(oldTypeMap);\n\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var typeName = _arr5[_i5];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr6 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var fieldName = _arr6[_i6];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr7 = Object.keys(oldTypeMap);\n\n  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n    var typeName = _arr7[_i7];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr8 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n      var fieldName = _arr8[_i8];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    } // Check if a field was added to the input object type\n\n\n    var _arr9 = Object.keys(newTypeFieldsDef);\n\n    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n      var _fieldName = _arr9[_i9];\n\n      if (!(_fieldName in oldTypeFieldsDef)) {\n        if (isRequiredInputField(newTypeFieldsDef[_fieldName])) {\n          breakingChanges.push({\n            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n            description: \"A required field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n            description: \"An optional field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n\n  var _arr10 = Object.keys(oldTypeMap);\n\n  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n    var typeName = _arr10[_i10];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var type = _step3.value;\n        typeNamesInNewUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _type = _step4.value;\n\n        if (!typeNamesInNewUnion[_type.name]) {\n          typesRemovedFromUnion.push({\n            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n            description: \"\".concat(_type.name, \" was removed from union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n\n  var _arr11 = Object.keys(newTypeMap);\n\n  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n    var typeName = _arr11[_i11];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var type = _step5.value;\n        typeNamesInOldUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _type2 = _step6.value;\n\n        if (!typeNamesInOldUnion[_type2.name]) {\n          typesAddedToUnion.push({\n            type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n            description: \"\".concat(_type2.name, \" was added to union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n\n  var _arr12 = Object.keys(oldTypeMap);\n\n  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n    var typeName = _arr12[_i12];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var value = _step7.value;\n        valuesInNewEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _value = _step8.value;\n\n        if (!valuesInNewEnum[_value.name]) {\n          valuesRemovedFromEnums.push({\n            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n            description: \"\".concat(_value.name, \" was removed from enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n\n  var _arr13 = Object.keys(oldTypeMap);\n\n  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n    var typeName = _arr13[_i13];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n        valuesInOldEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _value2 = _step10.value;\n\n        if (!valuesInOldEnum[_value2.name]) {\n          valuesAddedToEnums.push({\n            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n            description: \"\".concat(_value2.name, \" was added to enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n  }\n\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr14 = Object.keys(oldTypeMap);\n\n  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {\n    var typeName = _arr14[_i14];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      var _loop3 = function _loop3() {\n        var oldInterface = _step11.value;\n\n        if (!newInterfaces.some(function (int) {\n          return int.name === oldInterface.name;\n        })) {\n          breakingChanges.push({\n            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n            description: \"\".concat(typeName, \" no longer implements interface \") + \"\".concat(oldInterface.name, \".\")\n          });\n        }\n      };\n\n      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        _loop3();\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  var _arr15 = Object.keys(newTypeMap);\n\n  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {\n    var typeName = _arr15[_i15];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      var _loop4 = function _loop4() {\n        var newInterface = _step12.value;\n\n        if (!oldInterfaces.some(function (int) {\n          return int.name === newInterface.name;\n        })) {\n          interfacesAddedToObjectTypes.push({\n            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n            description: \"\".concat(newInterface.name, \" added to interfaces implemented \") + \"by \".concat(typeName, \".\")\n          });\n        }\n      };\n\n      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        _loop4();\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  }\n\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var directive = _step13.value;\n\n      if (!newSchemaDirectiveMap[directive.name]) {\n        removedDirectives.push({\n          type: BreakingChangeType.DIRECTIVE_REMOVED,\n          description: \"\".concat(directive.name, \" was removed\")\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var arg = _step14.value;\n\n      if (!newArgMap[arg.name]) {\n        removedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion15 = true;\n  var _didIteratorError15 = false;\n  var _iteratorError15 = undefined;\n\n  try {\n    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n      var newDirective = _step15.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var arg = _step16.value;\n          removedDirectiveArgs.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(arg.name, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError15 = true;\n    _iteratorError15 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n        _iterator15.return();\n      }\n    } finally {\n      if (_didIteratorError15) {\n        throw _iteratorError15;\n      }\n    }\n  }\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n\n  try {\n    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var arg = _step17.value;\n\n      if (!oldArgMap[arg.name]) {\n        addedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion18 = true;\n  var _didIteratorError18 = false;\n  var _iteratorError18 = undefined;\n\n  try {\n    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n      var newDirective = _step18.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var arg = _step19.value;\n\n          if (isRequiredArgument(arg)) {\n            addedNonNullableArgs.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(arg.name, \" on directive \") + \"\".concat(newDirective.name, \" was added\")\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError18 = true;\n    _iteratorError18 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n        _iterator18.return();\n      }\n    } finally {\n      if (_didIteratorError18) {\n        throw _iteratorError18;\n      }\n    }\n  }\n\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  var _iteratorNormalCompletion20 = true;\n  var _didIteratorError20 = false;\n  var _iteratorError20 = undefined;\n\n  try {\n    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n      var oldLocation = _step20.value;\n\n      if (!newLocationSet.has(oldLocation)) {\n        removedLocations.push(oldLocation);\n      }\n    }\n  } catch (err) {\n    _didIteratorError20 = true;\n    _iteratorError20 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n        _iterator20.return();\n      }\n    } finally {\n      if (_didIteratorError20) {\n        throw _iteratorError20;\n      }\n    }\n  }\n\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion21 = true;\n  var _didIteratorError21 = false;\n  var _iteratorError21 = undefined;\n\n  try {\n    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n      var newDirective = _step21.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion22 = true;\n      var _didIteratorError22 = false;\n      var _iteratorError22 = undefined;\n\n      try {\n        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n          var location = _step22.value;\n          removedLocations.push({\n            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n            description: \"\".concat(location, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError22 = true;\n        _iteratorError22 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n            _iterator22.return();\n          }\n        } finally {\n          if (_didIteratorError22) {\n            throw _iteratorError22;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError21 = true;\n    _iteratorError21 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n        _iterator21.return();\n      }\n    } finally {\n      if (_didIteratorError21) {\n        throw _iteratorError21;\n      }\n    }\n  }\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}