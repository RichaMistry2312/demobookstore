{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { assertValidSDL } from '../validation/validate';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { introspectionTypes } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { GraphQLSchema } from '../type/schema';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n  var schemaDef;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      var typeName = def.name.value;\n      if (nodeMap[typeName]) {\n        throw new Error(\"Type \\\"\".concat(typeName, \"\\\" was defined more than once.\"));\n      }\n      typeDefs.push(def);\n      nodeMap[typeName] = def;\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query,\n    mutation: nodeMap.Mutation,\n    subscription: nodeMap.Subscription\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {\n    throw new Error(\"Type \\\"\".concat(typeRef.name.value, \"\\\" not found in document.\"));\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: typeDefs.map(function (node) {\n      return definitionBuilder.buildType(node);\n    }),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var operationType = _step.value;\n        var _typeName = operationType.type.name.value;\n        var operation = operationType.operation;\n        if (opTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        }\n        if (!nodeMap[_typeName]) {\n          throw new Error(\"Specified \".concat(operation, \" type \\\"\").concat(_typeName, \"\\\" not found in document.\"));\n        }\n        opTypes[operation] = operationType.type;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return opTypes;\n  }\n}\nexport var ASTDefinitionBuilder = /*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _defineProperty(this, \"_typeDefinitionsMap\", void 0);\n    _defineProperty(this, \"_options\", void 0);\n    _defineProperty(this, \"_resolveType\", void 0);\n    _defineProperty(this, \"_cache\", void 0);\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n  var _proto = ASTDefinitionBuilder.prototype;\n  _proto.buildType = function buildType(node) {\n    var typeName = node.name.value;\n    if (!this._cache[typeName]) {\n      if (node.kind === Kind.NAMED_TYPE) {\n        var defNode = this._typeDefinitionsMap[typeName];\n        this._cache[typeName] = defNode ? this._makeSchemaDef(defNode) : this._resolveType(node);\n      } else {\n        this._cache[typeName] = this._makeSchemaDef(node);\n      }\n    }\n    return this._cache[typeName];\n  };\n  _proto._buildWrappedType = function _buildWrappedType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return GraphQLList(this._buildWrappedType(typeNode.type));\n    }\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      return GraphQLNonNull(\n      // Note: GraphQLNonNull constructor validates this type\n      this._buildWrappedType(typeNode.type));\n    }\n    return this.buildType(typeNode);\n  };\n  _proto.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n  _proto.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    var type = this._buildWrappedType(value.type);\n    return {\n      name: value.name.value,\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n  _proto._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n      default:\n        throw new Error(\"Type kind \\\"\".concat(def.kind, \"\\\" not supported.\"));\n    }\n  };\n  _proto._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n    var interfaces = def.interfaces;\n    return new GraphQLObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      // Note: While this could make early assertions to get the correctly\n      // typed values, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      interfaces: interfaces ? function () {\n        return interfaces.map(function (ref) {\n          return _this.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n  _proto._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n  _proto._makeInputValues = function _makeInputValues(values) {\n    var _this3 = this;\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      return _this3.buildInputField(value);\n    });\n  };\n  _proto._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this4 = this;\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this4._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n  _proto._makeEnumDef = function _makeEnumDef(def) {\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: this._makeValueDefMap(def),\n      astNode: def\n    });\n  };\n  _proto._makeValueDefMap = function _makeValueDefMap(def) {\n    var _this5 = this;\n    return def.values ? keyValMap(def.values, function (enumValue) {\n      return enumValue.name.value;\n    }, function (enumValue) {\n      return _this5.buildEnumValue(enumValue);\n    }) : {};\n  };\n  _proto._makeUnionDef = function _makeUnionDef(def) {\n    var _this6 = this;\n    var types = def.types;\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: types ? function () {\n        return types.map(function (ref) {\n          return _this6.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n  _proto._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this7._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  var comments = [];\n  var token = loc.startToken.prev;\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","invariant","keyMap","keyValMap","valueFromAST","assertValidSDL","blockStringValue","TokenKind","parse","getDirectiveValues","Kind","isTypeDefinitionNode","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","GraphQLDirective","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","introspectionTypes","specifiedScalarTypes","GraphQLSchema","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaDef","typeDefs","nodeMap","create","directiveDefs","i","definitions","length","def","SCHEMA_DEFINITION","typeName","name","Error","concat","push","DIRECTIVE_DEFINITION","operationTypes","getOperationTypes","query","Query","mutation","Mutation","subscription","Subscription","definitionBuilder","ASTDefinitionBuilder","typeRef","directives","map","buildDirective","some","directive","buildType","types","node","astNode","allowedLegacyNames","schema","opTypes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","operationType","_typeName","type","operation","err","return","typeDefinitionsMap","resolveType","_typeDefinitionsMap","_options","_resolveType","_cache","_proto","prototype","NAMED_TYPE","defNode","_makeSchemaDef","_buildWrappedType","typeNode","LIST_TYPE","NON_NULL_TYPE","directiveNode","description","getDescription","locations","args","arguments","_makeInputValues","buildField","field","deprecationReason","getDeprecationReason","buildInputField","defaultValue","buildEnumValue","OBJECT_TYPE_DEFINITION","_makeTypeDef","INTERFACE_TYPE_DEFINITION","_makeInterfaceDef","ENUM_TYPE_DEFINITION","_makeEnumDef","UNION_TYPE_DEFINITION","_makeUnionDef","SCALAR_TYPE_DEFINITION","_makeScalarDef","INPUT_OBJECT_TYPE_DEFINITION","_makeInputObjectDef","_this","interfaces","fields","_makeFieldDefMap","ref","_this2","values","_this3","_this4","_makeValueDefMap","_this5","enumValue","_this6","serialize","_this7","deprecated","reason","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","line","String","reverse","join","buildSchema","source"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { assertValidSDL } from '../validation/validate';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { introspectionTypes } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { GraphQLSchema } from '../type/schema';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      var typeName = def.name.value;\n\n      if (nodeMap[typeName]) {\n        throw new Error(\"Type \\\"\".concat(typeName, \"\\\" was defined more than once.\"));\n      }\n\n      typeDefs.push(def);\n      nodeMap[typeName] = def;\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query,\n    mutation: nodeMap.Mutation,\n    subscription: nodeMap.Subscription\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {\n    throw new Error(\"Type \\\"\".concat(typeRef.name.value, \"\\\" not found in document.\"));\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: typeDefs.map(function (node) {\n      return definitionBuilder.buildType(node);\n    }),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var operationType = _step.value;\n        var _typeName = operationType.type.name.value;\n        var operation = operationType.operation;\n\n        if (opTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        }\n\n        if (!nodeMap[_typeName]) {\n          throw new Error(\"Specified \".concat(operation, \" type \\\"\").concat(_typeName, \"\\\" not found in document.\"));\n        }\n\n        opTypes[operation] = operationType.type;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return opTypes;\n  }\n}\nexport var ASTDefinitionBuilder =\n/*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _defineProperty(this, \"_typeDefinitionsMap\", void 0);\n\n    _defineProperty(this, \"_options\", void 0);\n\n    _defineProperty(this, \"_resolveType\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.buildType = function buildType(node) {\n    var typeName = node.name.value;\n\n    if (!this._cache[typeName]) {\n      if (node.kind === Kind.NAMED_TYPE) {\n        var defNode = this._typeDefinitionsMap[typeName];\n        this._cache[typeName] = defNode ? this._makeSchemaDef(defNode) : this._resolveType(node);\n      } else {\n        this._cache[typeName] = this._makeSchemaDef(node);\n      }\n    }\n\n    return this._cache[typeName];\n  };\n\n  _proto._buildWrappedType = function _buildWrappedType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return GraphQLList(this._buildWrappedType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      return GraphQLNonNull( // Note: GraphQLNonNull constructor validates this type\n      this._buildWrappedType(typeNode.type));\n    }\n\n    return this.buildType(typeNode);\n  };\n\n  _proto.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    var type = this._buildWrappedType(value.type);\n\n    return {\n      name: value.name.value,\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n\n      default:\n        throw new Error(\"Type kind \\\"\".concat(def.kind, \"\\\" not supported.\"));\n    }\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var interfaces = def.interfaces;\n    return new GraphQLObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      // Note: While this could make early assertions to get the correctly\n      // typed values, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      interfaces: interfaces ? function () {\n        return interfaces.map(function (ref) {\n          return _this.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  _proto._makeInputValues = function _makeInputValues(values) {\n    var _this3 = this;\n\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      return _this3.buildInputField(value);\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this4 = this;\n\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this4._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(def) {\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: this._makeValueDefMap(def),\n      astNode: def\n    });\n  };\n\n  _proto._makeValueDefMap = function _makeValueDefMap(def) {\n    var _this5 = this;\n\n    return def.values ? keyValMap(def.values, function (enumValue) {\n      return enumValue.name.value;\n    }, function (enumValue) {\n      return _this5.buildEnumValue(enumValue);\n    }) : {};\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(def) {\n    var _this6 = this;\n\n    var types = def.types;\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: types ? function () {\n        return types.map(function (ref) {\n          return _this6.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this7._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}