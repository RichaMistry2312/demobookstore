{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of \") + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), [node]));\n      }\n    }\n  };\n}\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"names":["inspect","GraphQLError","doTypesOverlap","typeFromAST","isCompositeType","typeIncompatibleSpreadMessage","fragName","parentType","fragType","concat","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","context","InlineFragment","node","getType","getParentType","getSchema","reportError","FragmentSpread","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/validation/rules/PossibleFragmentSpreads.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of \") + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,uBAAuB;AAC3C,SAASC,YAAY,QAAQ,0BAA0B;AACvD,SAASC,cAAc,QAAQ,iCAAiC;AAChE,SAASC,WAAW,QAAQ,6BAA6B;AACzD,SAASC,eAAe,QAAQ,uBAAuB;AACvD,OAAO,SAASC,6BAA6BA,CAACC,QAAQ,EAAEC,UAAU,EAAEC,QAAQ,EAAE;EAC5E,OAAO,aAAa,CAACC,MAAM,CAACH,QAAQ,EAAE,yCAAyC,CAAC,GAAG,SAAS,CAACG,MAAM,CAACF,UAAU,EAAE,4BAA4B,CAAC,CAACE,MAAM,CAACD,QAAQ,EAAE,KAAK,CAAC;AACvK;AACA,OAAO,SAASE,iCAAiCA,CAACH,UAAU,EAAEC,QAAQ,EAAE;EACtE,OAAO,+CAA+C,GAAG,SAAS,CAACC,MAAM,CAACF,UAAU,EAAE,4BAA4B,CAAC,CAACE,MAAM,CAACD,QAAQ,EAAE,KAAK,CAAC;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,uBAAuBA,CAACC,OAAO,EAAE;EAC/C,OAAO;IACLC,cAAc,EAAE,SAASA,cAAcA,CAACC,IAAI,EAAE;MAC5C,IAAIN,QAAQ,GAAGI,OAAO,CAACG,OAAO,CAAC,CAAC;MAChC,IAAIR,UAAU,GAAGK,OAAO,CAACI,aAAa,CAAC,CAAC;MAExC,IAAIZ,eAAe,CAACI,QAAQ,CAAC,IAAIJ,eAAe,CAACG,UAAU,CAAC,IAAI,CAACL,cAAc,CAACU,OAAO,CAACK,SAAS,CAAC,CAAC,EAAET,QAAQ,EAAED,UAAU,CAAC,EAAE;QAC1HK,OAAO,CAACM,WAAW,CAAC,IAAIjB,YAAY,CAACS,iCAAiC,CAACV,OAAO,CAACO,UAAU,CAAC,EAAEP,OAAO,CAACQ,QAAQ,CAAC,CAAC,EAAE,CAACM,IAAI,CAAC,CAAC,CAAC;MAC1H;IACF,CAAC;IACDK,cAAc,EAAE,SAASA,cAAcA,CAACL,IAAI,EAAE;MAC5C,IAAIR,QAAQ,GAAGQ,IAAI,CAACM,IAAI,CAACC,KAAK;MAC9B,IAAIb,QAAQ,GAAGc,eAAe,CAACV,OAAO,EAAEN,QAAQ,CAAC;MACjD,IAAIC,UAAU,GAAGK,OAAO,CAACI,aAAa,CAAC,CAAC;MAExC,IAAIR,QAAQ,IAAID,UAAU,IAAI,CAACL,cAAc,CAACU,OAAO,CAACK,SAAS,CAAC,CAAC,EAAET,QAAQ,EAAED,UAAU,CAAC,EAAE;QACxFK,OAAO,CAACM,WAAW,CAAC,IAAIjB,YAAY,CAACI,6BAA6B,CAACC,QAAQ,EAAEN,OAAO,CAACO,UAAU,CAAC,EAAEP,OAAO,CAACQ,QAAQ,CAAC,CAAC,EAAE,CAACM,IAAI,CAAC,CAAC,CAAC;MAChI;IACF;EACF,CAAC;AACH;AAEA,SAASQ,eAAeA,CAACV,OAAO,EAAEQ,IAAI,EAAE;EACtC,IAAIG,IAAI,GAAGX,OAAO,CAACY,WAAW,CAACJ,IAAI,CAAC;EAEpC,IAAIG,IAAI,EAAE;IACR,IAAIE,IAAI,GAAGtB,WAAW,CAACS,OAAO,CAACK,SAAS,CAAC,CAAC,EAAEM,IAAI,CAACG,aAAa,CAAC;IAE/D,IAAItB,eAAe,CAACqB,IAAI,CAAC,EAAE;MACzB,OAAOA,IAAI;IACb;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module"}