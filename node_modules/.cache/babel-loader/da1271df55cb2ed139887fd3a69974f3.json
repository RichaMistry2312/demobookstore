{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\n    }\n    return getNamedType(typeRef.name);\n  }\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n    var typeIntrospection = typeIntrospectionMap[typeName];\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\n  }\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\n    }\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\n    }\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\n    }\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\n    }\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\n    }\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\n      }\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\n    }\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}","map":{"version":3,"names":["invariant","keyMap","keyValMap","valueFromAST","parseValue","GraphQLSchema","isInputType","isOutputType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","assertNullableType","assertObjectType","assertInterfaceType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","buildClientSchema","introspection","options","schemaIntrospection","__schema","typeIntrospectionMap","types","type","name","typeDefCache","concat","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","JSON","stringify","getNamedType","typeName","typeIntrospection","typeDef","buildType","getInputType","getOutputType","getObjectType","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","scalarIntrospection","description","serialize","value","objectIntrospection","interfaces","map","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","enumIntrospection","enumValues","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","buildInputValueDefMap","fieldIntrospection","args","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","buildDirective","directiveIntrospection","locations","slice","queryType","mutationType","subscriptionType","directives","query","mutation","subscription","assumeValid","allowedLegacyNames"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}