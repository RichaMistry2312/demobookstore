{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isAbstractType, isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport inspect from '../jsutils/inspect';\nimport { __Schema } from './introspection';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = /*#__PURE__*/\nfunction () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    _defineProperty(this, \"astNode\", void 0);\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n    _defineProperty(this, \"_queryType\", void 0);\n    _defineProperty(this, \"_mutationType\", void 0);\n    _defineProperty(this, \"_subscriptionType\", void 0);\n    _defineProperty(this, \"_directives\", void 0);\n    _defineProperty(this, \"_typeMap\", void 0);\n    _defineProperty(this, \"_implementations\", void 0);\n    _defineProperty(this, \"_possibleTypeMap\", void 0);\n    _defineProperty(this, \"__validationErrors\", void 0);\n    _defineProperty(this, \"__allowedLegacyNames\", void 0);\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !(_typeof(config) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\")) : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\")) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\")) : void 0;\n    }\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n    var types = config.types;\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    } // Keep track of all types referenced within the schema.\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap; // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n    var _arr = Object.keys(this._typeMap);\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var typeName = _arr[_i];\n      var type = this._typeMap[typeName];\n      if (isObjectType(type)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = type.getInterfaces()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var iface = _step.value;\n            if (isInterfaceType(iface)) {\n              var impls = this._implementations[iface.name];\n              if (impls) {\n                impls.push(type);\n              } else {\n                this._implementations[iface.name] = [type];\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else if (isAbstractType(type) && !this._implementations[type.name]) {\n        this._implementations[type.name] = [];\n      }\n    }\n  }\n  var _proto = GraphQLSchema.prototype;\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n    return this._implementations[abstractType.name];\n  };\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + \"types named \\\"\".concat(type.name, \"\\\".\")) : void 0;\n    return map;\n  }\n  map[type.name] = type;\n  var reducedMap = map;\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n    try {\n      for (var _iterator2 = objectValues(type.getFields())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var field = _step2.value;\n        if (field.args) {\n          var fieldArgTypes = field.args.map(function (arg) {\n            return arg.type;\n          });\n          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n        }\n        reducedMap = typeMapReducer(reducedMap, field.type);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n  if (isInputObjectType(type)) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n    try {\n      for (var _iterator3 = objectValues(type.getFields())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _field = _step3.value;\n        reducedMap = typeMapReducer(reducedMap, _field.type);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n  return reducedMap;\n}\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","isAbstractType","isObjectType","isInterfaceType","isUnionType","isInputObjectType","isWrappingType","GraphQLDirective","isDirective","specifiedDirectives","inspect","__Schema","defineToStringTag","find","instanceOf","invariant","objectValues","isSchema","schema","GraphQLSchema","config","assumeValid","__validationErrors","types","Array","isArray","concat","directives","allowedLegacyNames","__allowedLegacyNames","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","astNode","extensionASTNodes","initialTypes","getQueryType","getMutationType","getSubscriptionType","typeMap","create","reduce","typeMapReducer","typeMapDirectiveReducer","_typeMap","_implementations","_arr","keys","_i","length","typeName","type","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","getInterfaces","_step","next","done","iface","impls","name","push","err","return","_proto","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","isPossibleType","possibleType","possibleTypeMap","_possibleTypeMap","possibleTypes","map","Boolean","getDirectives","getDirective","directive","ofType","reducedMap","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","getFields","_step2","field","args","fieldArgTypes","arg","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_field","_map"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/type/schema.mjs"],"sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isAbstractType, isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport inspect from '../jsutils/inspect';\nimport { __Schema } from './introspection';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema =\n/*#__PURE__*/\nfunction () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_queryType\", void 0);\n\n    _defineProperty(this, \"_mutationType\", void 0);\n\n    _defineProperty(this, \"_subscriptionType\", void 0);\n\n    _defineProperty(this, \"_directives\", void 0);\n\n    _defineProperty(this, \"_typeMap\", void 0);\n\n    _defineProperty(this, \"_implementations\", void 0);\n\n    _defineProperty(this, \"_possibleTypeMap\", void 0);\n\n    _defineProperty(this, \"__validationErrors\", void 0);\n\n    _defineProperty(this, \"__allowedLegacyNames\", void 0);\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !(_typeof(config) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\")) : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\")) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\")) : void 0;\n    }\n\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n    var types = config.types;\n\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    } // Keep track of all types referenced within the schema.\n\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap; // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n\n    var _arr = Object.keys(this._typeMap);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var typeName = _arr[_i];\n      var type = this._typeMap[typeName];\n\n      if (isObjectType(type)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = type.getInterfaces()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var iface = _step.value;\n\n            if (isInterfaceType(iface)) {\n              var impls = this._implementations[iface.name];\n\n              if (impls) {\n                impls.push(type);\n              } else {\n                this._implementations[iface.name] = [type];\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else if (isAbstractType(type) && !this._implementations[type.name]) {\n        this._implementations[type.name] = [];\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name];\n  };\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + \"types named \\\"\".concat(type.name, \"\\\".\")) : void 0;\n    return map;\n  }\n\n  map[type.name] = type;\n  var reducedMap = map;\n\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = objectValues(type.getFields())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var field = _step2.value;\n\n        if (field.args) {\n          var fieldArgTypes = field.args.map(function (arg) {\n            return arg.type;\n          });\n          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n        }\n\n        reducedMap = typeMapReducer(reducedMap, field.type);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  if (isInputObjectType(type)) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = objectValues(type.getFields())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _field = _step3.value;\n        reducedMap = typeMapReducer(reducedMap, _field.type);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}