{"ast":null,"code":"var __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { makeCamelCaseArray, makeCamelCase } from './Utils';\nfunction getBoundingBox(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCase(geometry.BoundingBox);\n}\nfunction getPolygon(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCaseArray(Array.from(geometry.Polygon));\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeRekognitionBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  };\n  // We categorize each block by running a forEach loop through them.\n  blocks.forEach(function (block) {\n    switch (block.Type) {\n      case 'LINE':\n        response.text.lines.push(block.DetectedText);\n        response.text.linesDetailed.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: null\n        });\n        break;\n      case 'WORD':\n        response.text.fullText += block.DetectedText + ' ';\n        response.text.words.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        break;\n    }\n  });\n  // remove trailing space of fullText\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeTextractBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  };\n  // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n  if (blocks.length === 0) return response;\n  /**\n   * We categorize each of the blocks by running a forEach loop through them.\n   *\n   * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n   * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n   * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n   *\n   * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n   * block except the Page block.\n   */\n  var tableBlocks = Array();\n  var keyValueBlocks = Array();\n  var blockMap = {};\n  blocks.forEach(function (block) {\n    switch (block.BlockType) {\n      case 'LINE':\n        response.text.lines.push(block.Text);\n        response.text.linesDetailed.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: block.Page\n        });\n        break;\n      case 'WORD':\n        response.text.fullText += block.Text + ' ';\n        response.text.words.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n      case 'SELECTION_ELEMENT':\n        var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n        if (!response.text.selections) response.text.selections = [];\n        response.text.selections.push({\n          selected: selectionStatus,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n      case 'TABLE':\n        tableBlocks.push(block);\n        break;\n      case 'KEY_VALUE_SET':\n        keyValueBlocks.push(block);\n        blockMap[block.Id] = block;\n        break;\n      default:\n        blockMap[block.Id] = block;\n    }\n  });\n  // remove trailing space in fullText\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  // Post-process complex structures if they exist.\n  if (tableBlocks.length !== 0) {\n    var tableResponse_1 = Array();\n    tableBlocks.forEach(function (table) {\n      tableResponse_1.push(constructTable(table, blockMap));\n    });\n    response.text.tables = tableResponse_1;\n  }\n  if (keyValueBlocks.length !== 0) {\n    var keyValueResponse_1 = Array();\n    keyValueBlocks.forEach(function (keyValue) {\n      // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n      var entityTypes = Array.from(keyValue.EntityTypes);\n      if (entityTypes.indexOf('KEY') !== -1) {\n        keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n      }\n    });\n    response.text.keyValues = keyValueResponse_1;\n  }\n  return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructTable(table, blockMap) {\n  var e_1, _a, e_2, _b;\n  var tableMatrix;\n  tableMatrix = [];\n  try {\n    // visit each of the cell associated with the table's relationship.\n    for (var _c = __values(table.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var tableRelation = _d.value;\n      try {\n        for (var _e = (e_2 = void 0, __values(tableRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var cellId = _f.value;\n          var cellBlock = blockMap[cellId];\n          var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n          var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n          // extract data contained inside the cell.\n          var content = extractContentsFromBlock(cellBlock, blockMap);\n          var cell = {\n            text: content.text,\n            boundingBox: getBoundingBox(cellBlock.Geometry),\n            polygon: getPolygon(cellBlock.Geometry),\n            selected: content.selected,\n            rowSpan: cellBlock.RowSpan,\n            columnSpan: cellBlock.ColumnSpan\n          };\n          if (!tableMatrix[row]) tableMatrix[row] = [];\n          tableMatrix[row][col] = cell;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  var rowSize = tableMatrix.length;\n  var columnSize = tableMatrix[0].length;\n  // Note that we leave spanned cells undefined for distinction\n  return {\n    size: {\n      rows: rowSize,\n      columns: columnSize\n    },\n    table: tableMatrix,\n    boundingBox: getBoundingBox(table.Geometry),\n    polygon: getPolygon(table.Geometry)\n  };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructKeyValue(keyBlock, blockMap) {\n  var e_3, _a, e_4, _b;\n  var keyText = '';\n  var valueText = '';\n  var valueSelected;\n  try {\n    for (var _c = __values(keyBlock.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var keyValueRelation = _d.value;\n      if (keyValueRelation.Type === 'CHILD') {\n        // relation refers to key\n        var contents = extractContentsFromBlock(keyBlock, blockMap);\n        keyText = contents.text;\n      } else if (keyValueRelation.Type === 'VALUE') {\n        try {\n          // relation refers to value\n          for (var _e = (e_4 = void 0, __values(keyValueRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var valueId = _f.value;\n            var valueBlock = blockMap[valueId];\n            var contents = extractContentsFromBlock(valueBlock, blockMap);\n            valueText = contents.text;\n            if (contents.selected != null) valueSelected = contents.selected;\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n  return {\n    key: keyText,\n    value: {\n      text: valueText,\n      selected: valueSelected\n    },\n    polygon: getPolygon(keyBlock.Geometry),\n    boundingBox: getBoundingBox(keyBlock.Geometry)\n  };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function extractContentsFromBlock(block, blockMap) {\n  var e_5, _a, e_6, _b;\n  var words = '';\n  var isSelected;\n  if (!block.Relationships) {\n    // some block might have no content\n    return {\n      text: '',\n      selected: undefined\n    };\n  }\n  try {\n    for (var _c = __values(block.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var relation = _d.value;\n      try {\n        for (var _e = (e_6 = void 0, __values(relation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var contentId = _f.value;\n          var contentBlock = blockMap[contentId];\n          if (contentBlock.BlockType === 'WORD') {\n            words += contentBlock.Text + ' ';\n          } else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n            isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n    }\n  } catch (e_5_1) {\n    e_5 = {\n      error: e_5_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_5) throw e_5.error;\n    }\n  }\n  words = words.substr(0, words.length - 1); // remove trailing space.\n  return {\n    text: words,\n    selected: isSelected\n  };\n}","map":{"version":3,"names":["makeCamelCaseArray","makeCamelCase","getBoundingBox","geometry","undefined","BoundingBox","getPolygon","Array","from","Polygon","categorizeRekognitionBlocks","blocks","response","text","fullText","words","lines","linesDetailed","forEach","block","Type","push","DetectedText","polygon","Geometry","boundingBox","page","substr","length","categorizeTextractBlocks","tableBlocks","keyValueBlocks","blockMap","BlockType","Text","Page","Id","selectionStatus","SelectionStatus","selections","selected","tableResponse_1","table","constructTable","tables","keyValueResponse_1","keyValue","entityTypes","EntityTypes","indexOf","constructKeyValue","keyValues","tableMatrix","_c","__values","Relationships","_d","next","done","tableRelation","value","_e","e_2","Ids","_f","cellId","cellBlock","row","RowIndex","col","ColumnIndex","content","extractContentsFromBlock","cell","rowSpan","RowSpan","columnSpan","ColumnSpan","rowSize","columnSize","size","rows","columns","keyBlock","keyText","valueText","valueSelected","keyValueRelation","contents","e_4","valueId","valueBlock","key","isSelected","relation","e_6","contentId","contentBlock"],"sources":["../../src/Providers/IdentifyTextUtils.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}