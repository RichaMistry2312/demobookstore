{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport objectValues from '../jsutils/objectValues';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isIntrospectionType } from '../type/introspection';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      // Sanity check that none of the defined types conflict with the\n      // schema's existing types.\n      var typeName = def.name.value;\n      if (schema.getType(typeName)) {\n        throw new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also \") + 'be defined in this type definition.', [def]);\n      }\n      typeDefinitionMap[typeName] = def;\n    } else if (isTypeExtensionNode(def)) {\n      // Sanity check that this type extension exists within the\n      // schema's existing types.\n      var extendedTypeName = def.name.value;\n      var existingType = schema.getType(extendedTypeName);\n      if (!existingType) {\n        throw new GraphQLError(\"Cannot extend type \\\"\".concat(extendedTypeName, \"\\\" because it does not \") + 'exist in the existing schema.', [def]);\n      }\n      checkExtensionNode(existingType, def);\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var directiveName = def.name.value;\n      var existingDirective = schema.getDirective(directiveName);\n      if (existingDirective) {\n        throw new GraphQLError(\"Directive \\\"\".concat(directiveName, \"\\\" already exists in the schema. It \") + 'cannot be redefined.', [def]);\n      }\n      directiveDefinitions.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {\n    return schema;\n  }\n  var astBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n    if (existingType) {\n      return extendNamedType(existingType);\n    }\n    throw new GraphQLError(\"Unknown type: \\\"\".concat(typeName, \"\\\". Ensure that this type exists \") + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n  var extendTypeCache = Object.create(null); // Get the extended root operation types.\n\n  var operationTypes = {\n    query: extendMaybeNamedType(schema.getQueryType()),\n    mutation: extendMaybeNamedType(schema.getMutationType()),\n    subscription: extendMaybeNamedType(schema.getSubscriptionType())\n  };\n  if (schemaDef) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref2 = _step.value;\n        var operation = _ref2.operation,\n          type = _ref2.type;\n        if (operationTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        } // Note: While this could make early assertions to get the correctly\n        // typed values, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n\n        operationTypes[operation] = astBuilder.buildType(type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n  for (var _i = 0; _i < schemaExtensions.length; _i++) {\n    var schemaExtension = schemaExtensions[_i];\n    if (schemaExtension.operationTypes) {\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n      try {\n        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _ref4 = _step12.value;\n          var operation = _ref4.operation,\n            type = _ref4.type;\n          if (operationTypes[operation]) {\n            throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n          } // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n\n          operationTypes[operation] = astBuilder.buildType(type);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }\n  var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;\n  var types = objectValues(schema.getTypeMap()).map(function (type) {\n    return extendNamedType(type);\n  }).concat(objectValues(typeDefinitionMap).map(function (type) {\n    return astBuilder.buildType(type);\n  })); // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema(_objectSpread({}, operationTypes, {\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    extensionASTNodes: schemaExtensionASTNodes,\n    allowedLegacyNames: allowedLegacyNames\n  })); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n  function extendMaybeNamedType(type) {\n    return type ? extendNamedType(type) : null;\n  }\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n    var name = type.name;\n    if (!extendTypeCache[name]) {\n      if (isScalarType(type)) {\n        extendTypeCache[name] = extendScalarType(type);\n      } else if (isObjectType(type)) {\n        extendTypeCache[name] = extendObjectType(type);\n      } else if (isInterfaceType(type)) {\n        extendTypeCache[name] = extendInterfaceType(type);\n      } else if (isUnionType(type)) {\n        extendTypeCache[name] = extendUnionType(type);\n      } else if (isEnumType(type)) {\n        extendTypeCache[name] = extendEnumType(type);\n      } else if (isInputObjectType(type)) {\n        extendTypeCache[name] = extendInputObjectType(type);\n      }\n    }\n    return extendTypeCache[name];\n  }\n  function extendDirective(directive) {\n    return new GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: directive.locations,\n      args: extendArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n  function extendInputObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInputObjectType({\n      name: name,\n      description: type.description,\n      fields: function fields() {\n        return extendInputFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n  function extendInputFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    var _arr = Object.keys(oldFieldMap);\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var _fieldName = _arr[_i2];\n      var _field = oldFieldMap[_fieldName];\n      newFieldMap[_fieldName] = {\n        description: _field.description,\n        type: extendType(_field.type),\n        defaultValue: _field.defaultValue,\n        astNode: _field.astNode\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extension = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n          try {\n            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var field = _step3.value;\n              var fieldName = field.name.value;\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n              newFieldMap[fieldName] = astBuilder.buildInputField(field);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n    return newFieldMap;\n  }\n  function extendEnumType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLEnumType({\n      name: name,\n      description: type.description,\n      values: extendValueMap(type),\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n  function extendValueMap(type) {\n    var newValueMap = Object.create(null);\n    var oldValueMap = keyMap(type.getValues(), function (value) {\n      return value.name;\n    });\n    var _arr2 = Object.keys(oldValueMap);\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var _valueName = _arr2[_i3];\n      var _value = oldValueMap[_valueName];\n      newValueMap[_valueName] = {\n        name: _value.name,\n        description: _value.description,\n        value: _value.value,\n        deprecationReason: _value.deprecationReason,\n        astNode: _value.astNode\n      };\n    } // If there are any extensions to the values, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n      try {\n        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var extension = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n          try {\n            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var value = _step5.value;\n              var valueName = value.name.value;\n              if (oldValueMap[valueName]) {\n                throw new GraphQLError(\"Enum value \\\"\".concat(type.name, \".\").concat(valueName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [value]);\n              }\n              newValueMap[valueName] = astBuilder.buildEnumValue(value);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n    return newValueMap;\n  }\n  function extendScalarType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLScalarType({\n      name: name,\n      description: type.description,\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      serialize: type.serialize,\n      parseValue: type.parseValue,\n      parseLiteral: type.parseLiteral\n    });\n  }\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n  function extendArgs(args) {\n    return keyValMap(args, function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return {\n        type: extendType(arg.type),\n        defaultValue: arg.defaultValue,\n        description: arg.description,\n        astNode: arg.astNode\n      };\n    });\n  }\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n  function extendUnionType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLUnionType({\n      name: name,\n      description: type.description,\n      types: function types() {\n        return extendPossibleTypes(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n  function extendPossibleTypes(type) {\n    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n      try {\n        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var extension = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n          try {\n            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var namedType = _step7.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              possibleTypes.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n    return possibleTypes;\n  }\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n      try {\n        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var extension = _step8.value;\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n          try {\n            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var namedType = _step9.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              interfaces.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n    return interfaces;\n  }\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    var _arr3 = Object.keys(oldFieldMap);\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var _fieldName2 = _arr3[_i4];\n      var _field2 = oldFieldMap[_fieldName2];\n      newFieldMap[_fieldName2] = {\n        description: _field2.description,\n        deprecationReason: _field2.deprecationReason,\n        type: extendType(_field2.type),\n        args: extendArgs(_field2.args),\n        astNode: _field2.astNode,\n        resolve: _field2.resolve\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n      try {\n        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var extension = _step10.value;\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n          try {\n            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var field = _step11.value;\n              var fieldName = field.name.value;\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n              newFieldMap[fieldName] = astBuilder.buildField(field);\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n    return newFieldMap;\n  }\n  function extendType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendType(typeDef.ofType));\n    }\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendType(typeDef.ofType));\n    }\n    return extendNamedType(typeDef);\n  }\n}\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_EXTENSION:\n      if (!isObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n      break;\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      if (!isInterfaceType(type)) {\n        throw new GraphQLError(\"Cannot extend non-interface type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n      break;\n    case Kind.ENUM_TYPE_EXTENSION:\n      if (!isEnumType(type)) {\n        throw new GraphQLError(\"Cannot extend non-enum type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n      break;\n    case Kind.UNION_TYPE_EXTENSION:\n      if (!isUnionType(type)) {\n        throw new GraphQLError(\"Cannot extend non-union type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n      break;\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      if (!isInputObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-input object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n      break;\n  }\n}","map":{"version":3,"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","invariant","keyMap","keyValMap","objectValues","ASTDefinitionBuilder","assertValidSDLExtension","GraphQLError","isSchema","GraphQLSchema","isIntrospectionType","isSpecifiedScalarType","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLDirective","Kind","isTypeDefinitionNode","isTypeExtensionNode","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","typeDefinitionMap","create","typeExtensionsMap","directiveDefinitions","schemaDef","schemaExtensions","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","push","typeName","name","getType","extendedTypeName","existingType","checkExtensionNode","existingTypeExtensions","DIRECTIVE_DEFINITION","directiveName","existingDirective","getDirective","astBuilder","typeRef","extendNamedType","extendTypeCache","operationTypes","query","extendMaybeNamedType","getQueryType","mutation","getMutationType","subscription","getSubscriptionType","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","_ref2","operation","type","Error","buildType","err","return","_i","schemaExtension","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","_ref4","schemaExtensionASTNodes","extensionASTNodes","types","getTypeMap","map","allowedLegacyNames","__allowedLegacyNames","directives","getMergedDirectives","astNode","existingDirectives","getDirectives","extendDirective","node","buildDirective","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","directive","description","locations","args","extendArgs","fields","extendInputFieldMap","newFieldMap","oldFieldMap","getFields","_arr","_i2","_fieldName","_field","extendType","defaultValue","extensions","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","extension","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","field","fieldName","buildInputField","values","extendValueMap","newValueMap","oldValueMap","getValues","_arr2","_i3","_valueName","_value","deprecationReason","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","valueName","buildEnumValue","serialize","parseValue","parseLiteral","interfaces","extendImplementedInterfaces","extendFieldMap","isTypeOf","arg","resolveType","extendPossibleTypes","possibleTypes","getTypes","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","namedType","getInterfaces","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_arr3","_i4","_fieldName2","_field2","resolve","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_iterator11","_step11","buildField","typeDef","ofType","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","UNION_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/utilities/extendSchema.mjs"],"sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport objectValues from '../jsutils/objectValues';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isIntrospectionType } from '../type/introspection';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      // Sanity check that none of the defined types conflict with the\n      // schema's existing types.\n      var typeName = def.name.value;\n\n      if (schema.getType(typeName)) {\n        throw new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also \") + 'be defined in this type definition.', [def]);\n      }\n\n      typeDefinitionMap[typeName] = def;\n    } else if (isTypeExtensionNode(def)) {\n      // Sanity check that this type extension exists within the\n      // schema's existing types.\n      var extendedTypeName = def.name.value;\n      var existingType = schema.getType(extendedTypeName);\n\n      if (!existingType) {\n        throw new GraphQLError(\"Cannot extend type \\\"\".concat(extendedTypeName, \"\\\" because it does not \") + 'exist in the existing schema.', [def]);\n      }\n\n      checkExtensionNode(existingType, def);\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var directiveName = def.name.value;\n      var existingDirective = schema.getDirective(directiveName);\n\n      if (existingDirective) {\n        throw new GraphQLError(\"Directive \\\"\".concat(directiveName, \"\\\" already exists in the schema. It \") + 'cannot be redefined.', [def]);\n      }\n\n      directiveDefinitions.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendNamedType(existingType);\n    }\n\n    throw new GraphQLError(\"Unknown type: \\\"\".concat(typeName, \"\\\". Ensure that this type exists \") + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n  var extendTypeCache = Object.create(null); // Get the extended root operation types.\n\n  var operationTypes = {\n    query: extendMaybeNamedType(schema.getQueryType()),\n    mutation: extendMaybeNamedType(schema.getMutationType()),\n    subscription: extendMaybeNamedType(schema.getSubscriptionType())\n  };\n\n  if (schemaDef) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref2 = _step.value;\n        var operation = _ref2.operation,\n            type = _ref2.type;\n\n        if (operationTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        } // Note: While this could make early assertions to get the correctly\n        // typed values, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n\n\n        operationTypes[operation] = astBuilder.buildType(type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i = 0; _i < schemaExtensions.length; _i++) {\n    var schemaExtension = schemaExtensions[_i];\n\n    if (schemaExtension.operationTypes) {\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _ref4 = _step12.value;\n          var operation = _ref4.operation,\n              type = _ref4.type;\n\n          if (operationTypes[operation]) {\n            throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n          } // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n\n\n          operationTypes[operation] = astBuilder.buildType(type);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }\n\n  var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;\n  var types = objectValues(schema.getTypeMap()).map(function (type) {\n    return extendNamedType(type);\n  }).concat(objectValues(typeDefinitionMap).map(function (type) {\n    return astBuilder.buildType(type);\n  })); // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n\n  return new GraphQLSchema(_objectSpread({}, operationTypes, {\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    extensionASTNodes: schemaExtensionASTNodes,\n    allowedLegacyNames: allowedLegacyNames\n  })); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendMaybeNamedType(type) {\n    return type ? extendNamedType(type) : null;\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    var name = type.name;\n\n    if (!extendTypeCache[name]) {\n      if (isScalarType(type)) {\n        extendTypeCache[name] = extendScalarType(type);\n      } else if (isObjectType(type)) {\n        extendTypeCache[name] = extendObjectType(type);\n      } else if (isInterfaceType(type)) {\n        extendTypeCache[name] = extendInterfaceType(type);\n      } else if (isUnionType(type)) {\n        extendTypeCache[name] = extendUnionType(type);\n      } else if (isEnumType(type)) {\n        extendTypeCache[name] = extendEnumType(type);\n      } else if (isInputObjectType(type)) {\n        extendTypeCache[name] = extendInputObjectType(type);\n      }\n    }\n\n    return extendTypeCache[name];\n  }\n\n  function extendDirective(directive) {\n    return new GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: directive.locations,\n      args: extendArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n\n  function extendInputObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInputObjectType({\n      name: name,\n      description: type.description,\n      fields: function fields() {\n        return extendInputFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendInputFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr = Object.keys(oldFieldMap);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var _fieldName = _arr[_i2];\n      var _field = oldFieldMap[_fieldName];\n      newFieldMap[_fieldName] = {\n        description: _field.description,\n        type: extendType(_field.type),\n        defaultValue: _field.defaultValue,\n        astNode: _field.astNode\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extension = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var field = _step3.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildInputField(field);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendEnumType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLEnumType({\n      name: name,\n      description: type.description,\n      values: extendValueMap(type),\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendValueMap(type) {\n    var newValueMap = Object.create(null);\n    var oldValueMap = keyMap(type.getValues(), function (value) {\n      return value.name;\n    });\n\n    var _arr2 = Object.keys(oldValueMap);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var _valueName = _arr2[_i3];\n      var _value = oldValueMap[_valueName];\n      newValueMap[_valueName] = {\n        name: _value.name,\n        description: _value.description,\n        value: _value.value,\n        deprecationReason: _value.deprecationReason,\n        astNode: _value.astNode\n      };\n    } // If there are any extensions to the values, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var extension = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var value = _step5.value;\n              var valueName = value.name.value;\n\n              if (oldValueMap[valueName]) {\n                throw new GraphQLError(\"Enum value \\\"\".concat(type.name, \".\").concat(valueName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [value]);\n              }\n\n              newValueMap[valueName] = astBuilder.buildEnumValue(value);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    return newValueMap;\n  }\n\n  function extendScalarType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLScalarType({\n      name: name,\n      description: type.description,\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      serialize: type.serialize,\n      parseValue: type.parseValue,\n      parseLiteral: type.parseLiteral\n    });\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendArgs(args) {\n    return keyValMap(args, function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return {\n        type: extendType(arg.type),\n        defaultValue: arg.defaultValue,\n        description: arg.description,\n        astNode: arg.astNode\n      };\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLUnionType({\n      name: name,\n      description: type.description,\n      types: function types() {\n        return extendPossibleTypes(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendPossibleTypes(type) {\n    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var extension = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var namedType = _step7.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              possibleTypes.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    return possibleTypes;\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var extension = _step8.value;\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var namedType = _step9.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              interfaces.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr3 = Object.keys(oldFieldMap);\n\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var _fieldName2 = _arr3[_i4];\n      var _field2 = oldFieldMap[_fieldName2];\n      newFieldMap[_fieldName2] = {\n        description: _field2.description,\n        deprecationReason: _field2.deprecationReason,\n        type: extendType(_field2.type),\n        args: extendArgs(_field2.args),\n        astNode: _field2.astNode,\n        resolve: _field2.resolve\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var extension = _step10.value;\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var field = _step11.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildField(field);\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendType(typeDef.ofType));\n    }\n\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendType(typeDef.ofType));\n    }\n\n    return extendNamedType(typeDef);\n  }\n}\n\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_EXTENSION:\n      if (!isObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      if (!isInterfaceType(type)) {\n        throw new GraphQLError(\"Cannot extend non-interface type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      if (!isEnumType(type)) {\n        throw new GraphQLError(\"Cannot extend non-enum type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.UNION_TYPE_EXTENSION:\n      if (!isUnionType(type)) {\n        throw new GraphQLError(\"Cannot extend non-union type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      if (!isInputObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-input object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}