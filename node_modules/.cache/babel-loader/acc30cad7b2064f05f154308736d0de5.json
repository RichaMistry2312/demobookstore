{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { isExecutableDefinitionNode } from '../../language/predicates';\nexport function nonExecutableDefinitionMessage(defName) {\n  return \"The \".concat(defName, \" definition is not executable.\");\n}\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\n\nexport function ExecutableDefinitions(context) {\n  return {\n    Document: function Document(node) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = node.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var definition = _step.value;\n          if (!isExecutableDefinitionNode(definition)) {\n            context.reportError(new GraphQLError(nonExecutableDefinitionMessage(definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : definition.name.value), [definition]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return false;\n    }\n  };\n}","map":{"version":3,"names":["GraphQLError","Kind","isExecutableDefinitionNode","nonExecutableDefinitionMessage","defName","concat","ExecutableDefinitions","context","Document","node","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","definitions","Symbol","iterator","_step","next","done","definition","value","reportError","kind","SCHEMA_DEFINITION","SCHEMA_EXTENSION","name","err","return"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/validation/rules/ExecutableDefinitions.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { isExecutableDefinitionNode } from '../../language/predicates';\nexport function nonExecutableDefinitionMessage(defName) {\n  return \"The \".concat(defName, \" definition is not executable.\");\n}\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\n\nexport function ExecutableDefinitions(context) {\n  return {\n    Document: function Document(node) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = node.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var definition = _step.value;\n\n          if (!isExecutableDefinitionNode(definition)) {\n            context.reportError(new GraphQLError(nonExecutableDefinitionMessage(definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : definition.name.value), [definition]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,0BAA0B;AACvD,SAASC,IAAI,QAAQ,sBAAsB;AAC3C,SAASC,0BAA0B,QAAQ,2BAA2B;AACtE,OAAO,SAASC,8BAA8BA,CAACC,OAAO,EAAE;EACtD,OAAO,MAAM,CAACC,MAAM,CAACD,OAAO,EAAE,gCAAgC,CAAC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,qBAAqBA,CAACC,OAAO,EAAE;EAC7C,OAAO;IACLC,QAAQ,EAAE,SAASA,QAAQA,CAACC,IAAI,EAAE;MAChC,IAAIC,yBAAyB,GAAG,IAAI;MACpC,IAAIC,iBAAiB,GAAG,KAAK;MAC7B,IAAIC,cAAc,GAAGC,SAAS;MAE9B,IAAI;QACF,KAAK,IAAIC,SAAS,GAAGL,IAAI,CAACM,WAAW,CAACC,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAEC,KAAK,EAAE,EAAER,yBAAyB,GAAG,CAACQ,KAAK,GAAGJ,SAAS,CAACK,IAAI,CAAC,CAAC,EAAEC,IAAI,CAAC,EAAEV,yBAAyB,GAAG,IAAI,EAAE;UACjK,IAAIW,UAAU,GAAGH,KAAK,CAACI,KAAK;UAE5B,IAAI,CAACpB,0BAA0B,CAACmB,UAAU,CAAC,EAAE;YAC3Cd,OAAO,CAACgB,WAAW,CAAC,IAAIvB,YAAY,CAACG,8BAA8B,CAACkB,UAAU,CAACG,IAAI,KAAKvB,IAAI,CAACwB,iBAAiB,IAAIJ,UAAU,CAACG,IAAI,KAAKvB,IAAI,CAACyB,gBAAgB,GAAG,QAAQ,GAAGL,UAAU,CAACM,IAAI,CAACL,KAAK,CAAC,EAAE,CAACD,UAAU,CAAC,CAAC,CAAC;UACjN;QACF;MACF,CAAC,CAAC,OAAOO,GAAG,EAAE;QACZjB,iBAAiB,GAAG,IAAI;QACxBC,cAAc,GAAGgB,GAAG;MACtB,CAAC,SAAS;QACR,IAAI;UACF,IAAI,CAAClB,yBAAyB,IAAII,SAAS,CAACe,MAAM,IAAI,IAAI,EAAE;YAC1Df,SAAS,CAACe,MAAM,CAAC,CAAC;UACpB;QACF,CAAC,SAAS;UACR,IAAIlB,iBAAiB,EAAE;YACrB,MAAMC,cAAc;UACtB;QACF;MACF;MAEA,OAAO,KAAK;IACd;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module"}