{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport suggestionList from '../../jsutils/suggestionList';\nimport quotedOrList from '../../jsutils/quotedOrList';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var message = \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\");\n  if (suggestedTypeNames.length !== 0) {\n    var suggestions = quotedOrList(suggestedTypeNames);\n    message += \" Did you mean to use an inline fragment on \".concat(suggestions, \"?\");\n  } else if (suggestedFieldNames.length !== 0) {\n    message += \" Did you mean \".concat(quotedOrList(suggestedFieldNames), \"?\");\n  }\n  return message;\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n      if (type) {\n        var fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (var _iterator = schema.getPossibleTypes(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var possibleType = _step.value;\n        if (!possibleType.getFields()[fieldName]) {\n          continue;\n        } // This object type defines this field.\n\n        suggestedObjectTypes.push(possibleType.name);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = possibleType.getInterfaces()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var possibleInterface = _step2.value;\n            if (!possibleInterface.getFields()[fieldName]) {\n              continue;\n            } // This interface type defines this field.\n\n            interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // Suggest interface types based on how common they are.\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}","map":{"version":3,"names":["GraphQLError","suggestionList","quotedOrList","isObjectType","isInterfaceType","isAbstractType","undefinedFieldMessage","fieldName","type","suggestedTypeNames","suggestedFieldNames","message","concat","length","suggestions","FieldsOnCorrectType","context","Field","node","getParentType","fieldDef","getFieldDef","schema","getSchema","name","value","getSuggestedTypeNames","getSuggestedFieldNames","reportError","suggestedObjectTypes","interfaceUsageCount","Object","create","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","getPossibleTypes","Symbol","iterator","_step","next","done","possibleType","getFields","push","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","getInterfaces","_step2","possibleInterface","err","return","suggestedInterfaceTypes","keys","sort","a","b","possibleFieldNames"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/validation/rules/FieldsOnCorrectType.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport suggestionList from '../../jsutils/suggestionList';\nimport quotedOrList from '../../jsutils/quotedOrList';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var message = \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\");\n\n  if (suggestedTypeNames.length !== 0) {\n    var suggestions = quotedOrList(suggestedTypeNames);\n    message += \" Did you mean to use an inline fragment on \".concat(suggestions, \"?\");\n  } else if (suggestedFieldNames.length !== 0) {\n    message += \" Did you mean \".concat(quotedOrList(suggestedFieldNames), \"?\");\n  }\n\n  return message;\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.getPossibleTypes(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var possibleType = _step.value;\n\n        if (!possibleType.getFields()[fieldName]) {\n          continue;\n        } // This object type defines this field.\n\n\n        suggestedObjectTypes.push(possibleType.name);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = possibleType.getInterfaces()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var possibleInterface = _step2.value;\n\n            if (!possibleInterface.getFields()[fieldName]) {\n              continue;\n            } // This interface type defines this field.\n\n\n            interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // Suggest interface types based on how common they are.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,0BAA0B;AACvD,OAAOC,cAAc,MAAM,8BAA8B;AACzD,OAAOC,YAAY,MAAM,4BAA4B;AACrD,SAASC,YAAY,EAAEC,eAAe,EAAEC,cAAc,QAAQ,uBAAuB;AACrF,OAAO,SAASC,qBAAqBA,CAACC,SAAS,EAAEC,IAAI,EAAEC,kBAAkB,EAAEC,mBAAmB,EAAE;EAC9F,IAAIC,OAAO,GAAG,uBAAuB,CAACC,MAAM,CAACL,SAAS,EAAE,eAAe,CAAC,CAACK,MAAM,CAACJ,IAAI,EAAE,KAAK,CAAC;EAE5F,IAAIC,kBAAkB,CAACI,MAAM,KAAK,CAAC,EAAE;IACnC,IAAIC,WAAW,GAAGZ,YAAY,CAACO,kBAAkB,CAAC;IAClDE,OAAO,IAAI,6CAA6C,CAACC,MAAM,CAACE,WAAW,EAAE,GAAG,CAAC;EACnF,CAAC,MAAM,IAAIJ,mBAAmB,CAACG,MAAM,KAAK,CAAC,EAAE;IAC3CF,OAAO,IAAI,gBAAgB,CAACC,MAAM,CAACV,YAAY,CAACQ,mBAAmB,CAAC,EAAE,GAAG,CAAC;EAC5E;EAEA,OAAOC,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASI,mBAAmBA,CAACC,OAAO,EAAE;EAC3C,OAAO;IACLC,KAAK,EAAE,SAASA,KAAKA,CAACC,IAAI,EAAE;MAC1B,IAAIV,IAAI,GAAGQ,OAAO,CAACG,aAAa,CAAC,CAAC;MAElC,IAAIX,IAAI,EAAE;QACR,IAAIY,QAAQ,GAAGJ,OAAO,CAACK,WAAW,CAAC,CAAC;QAEpC,IAAI,CAACD,QAAQ,EAAE;UACb;UACA,IAAIE,MAAM,GAAGN,OAAO,CAACO,SAAS,CAAC,CAAC;UAChC,IAAIhB,SAAS,GAAGW,IAAI,CAACM,IAAI,CAACC,KAAK,CAAC,CAAC;;UAEjC,IAAIhB,kBAAkB,GAAGiB,qBAAqB,CAACJ,MAAM,EAAEd,IAAI,EAAED,SAAS,CAAC,CAAC,CAAC;;UAEzE,IAAIG,mBAAmB,GAAGD,kBAAkB,CAACI,MAAM,KAAK,CAAC,GAAG,EAAE,GAAGc,sBAAsB,CAACL,MAAM,EAAEd,IAAI,EAAED,SAAS,CAAC,CAAC,CAAC;;UAElHS,OAAO,CAACY,WAAW,CAAC,IAAI5B,YAAY,CAACM,qBAAqB,CAACC,SAAS,EAAEC,IAAI,CAACgB,IAAI,EAAEf,kBAAkB,EAAEC,mBAAmB,CAAC,EAAE,CAACQ,IAAI,CAAC,CAAC,CAAC;QACrI;MACF;IACF;EACF,CAAC;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASQ,qBAAqBA,CAACJ,MAAM,EAAEd,IAAI,EAAED,SAAS,EAAE;EACtD,IAAIF,cAAc,CAACG,IAAI,CAAC,EAAE;IACxB,IAAIqB,oBAAoB,GAAG,EAAE;IAC7B,IAAIC,mBAAmB,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;IAC7C,IAAIC,yBAAyB,GAAG,IAAI;IACpC,IAAIC,iBAAiB,GAAG,KAAK;IAC7B,IAAIC,cAAc,GAAGC,SAAS;IAE9B,IAAI;MACF,KAAK,IAAIC,SAAS,GAAGf,MAAM,CAACgB,gBAAgB,CAAC9B,IAAI,CAAC,CAAC+B,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAEC,KAAK,EAAE,EAAER,yBAAyB,GAAG,CAACQ,KAAK,GAAGJ,SAAS,CAACK,IAAI,CAAC,CAAC,EAAEC,IAAI,CAAC,EAAEV,yBAAyB,GAAG,IAAI,EAAE;QAC9K,IAAIW,YAAY,GAAGH,KAAK,CAAChB,KAAK;QAE9B,IAAI,CAACmB,YAAY,CAACC,SAAS,CAAC,CAAC,CAACtC,SAAS,CAAC,EAAE;UACxC;QACF,CAAC,CAAC;;QAGFsB,oBAAoB,CAACiB,IAAI,CAACF,YAAY,CAACpB,IAAI,CAAC;QAC5C,IAAIuB,0BAA0B,GAAG,IAAI;QACrC,IAAIC,kBAAkB,GAAG,KAAK;QAC9B,IAAIC,eAAe,GAAGb,SAAS;QAE/B,IAAI;UACF,KAAK,IAAIc,UAAU,GAAGN,YAAY,CAACO,aAAa,CAAC,CAAC,CAACZ,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAEY,MAAM,EAAE,EAAEL,0BAA0B,GAAG,CAACK,MAAM,GAAGF,UAAU,CAACR,IAAI,CAAC,CAAC,EAAEC,IAAI,CAAC,EAAEI,0BAA0B,GAAG,IAAI,EAAE;YACnL,IAAIM,iBAAiB,GAAGD,MAAM,CAAC3B,KAAK;YAEpC,IAAI,CAAC4B,iBAAiB,CAACR,SAAS,CAAC,CAAC,CAACtC,SAAS,CAAC,EAAE;cAC7C;YACF,CAAC,CAAC;;YAGFuB,mBAAmB,CAACuB,iBAAiB,CAAC7B,IAAI,CAAC,GAAG,CAACM,mBAAmB,CAACuB,iBAAiB,CAAC7B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;UACtG;QACF,CAAC,CAAC,OAAO8B,GAAG,EAAE;UACZN,kBAAkB,GAAG,IAAI;UACzBC,eAAe,GAAGK,GAAG;QACvB,CAAC,SAAS;UACR,IAAI;YACF,IAAI,CAACP,0BAA0B,IAAIG,UAAU,CAACK,MAAM,IAAI,IAAI,EAAE;cAC5DL,UAAU,CAACK,MAAM,CAAC,CAAC;YACrB;UACF,CAAC,SAAS;YACR,IAAIP,kBAAkB,EAAE;cACtB,MAAMC,eAAe;YACvB;UACF;QACF;MACF,CAAC,CAAC;IAEJ,CAAC,CAAC,OAAOK,GAAG,EAAE;MACZpB,iBAAiB,GAAG,IAAI;MACxBC,cAAc,GAAGmB,GAAG;IACtB,CAAC,SAAS;MACR,IAAI;QACF,IAAI,CAACrB,yBAAyB,IAAII,SAAS,CAACkB,MAAM,IAAI,IAAI,EAAE;UAC1DlB,SAAS,CAACkB,MAAM,CAAC,CAAC;QACpB;MACF,CAAC,SAAS;QACR,IAAIrB,iBAAiB,EAAE;UACrB,MAAMC,cAAc;QACtB;MACF;IACF;IAEA,IAAIqB,uBAAuB,GAAGzB,MAAM,CAAC0B,IAAI,CAAC3B,mBAAmB,CAAC,CAAC4B,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MAClF,OAAO9B,mBAAmB,CAAC8B,CAAC,CAAC,GAAG9B,mBAAmB,CAAC6B,CAAC,CAAC;IACxD,CAAC,CAAC,CAAC,CAAC;;IAEJ,OAAOH,uBAAuB,CAAC5C,MAAM,CAACiB,oBAAoB,CAAC;EAC7D,CAAC,CAAC;;EAGF,OAAO,EAAE;AACX;AACA;AACA;AACA;AACA;;AAGA,SAASF,sBAAsBA,CAACL,MAAM,EAAEd,IAAI,EAAED,SAAS,EAAE;EACvD,IAAIJ,YAAY,CAACK,IAAI,CAAC,IAAIJ,eAAe,CAACI,IAAI,CAAC,EAAE;IAC/C,IAAIqD,kBAAkB,GAAG9B,MAAM,CAAC0B,IAAI,CAACjD,IAAI,CAACqC,SAAS,CAAC,CAAC,CAAC;IACtD,OAAO5C,cAAc,CAACM,SAAS,EAAEsD,kBAAkB,CAAC;EACtD,CAAC,CAAC;;EAGF,OAAO,EAAE;AACX","ignoreList":[]},"metadata":{},"sourceType":"module"}