{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport inspect from '../../jsutils/inspect';\nimport find from '../../jsutils/find';\nimport { Kind } from '../../language/kinds';\nimport { print } from '../../language/printer';\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nexport function fieldsConflictMessage(responseName, reason) {\n  return \"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(reason)) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n        subreason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(subreason));\n    }).join(' and ');\n  }\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\nexport function OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      for (var _i = 0; _i < conflicts.length; _i++) {\n        var _ref3 = conflicts[_i];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n    fieldMap = _getFieldsAndFragment[0],\n    fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n  comparedFragments[fragmentName] = true;\n  var fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n    fieldMap2 = _getReferencedFieldsA[0],\n    fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n    fieldMap1 = _getReferencedFieldsA2[0],\n    fragmentNames1 = _getReferencedFieldsA2[1];\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n    fieldMap2 = _getReferencedFieldsA3[0],\n    fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n    fieldMap1 = _getFieldsAndFragment2[0],\n    fragmentNames1 = _getFieldsAndFragment2[1];\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n    fieldMap2 = _getFieldsAndFragment3[0],\n    fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (var _i2 = 0; _i2 < fragmentNames1.length; _i2++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i2], fragmentNames2[_j]);\n    }\n  }\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  var _arr = Object.keys(fieldMap);\n  for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n    var responseName = _arr[_i3];\n    var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false,\n          // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  var _arr2 = Object.keys(fieldMap1);\n  for (var _i4 = 0; _i4 < _arr2.length; _i4++) {\n    var responseName = _arr2[_i4];\n    var fields2 = fieldMap2[responseName];\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n    node1 = field1[1],\n    def1 = field1[2];\n  var parentType2 = field2[0],\n    node2 = field2[1],\n    def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2); // The return type for each field.\n\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, \"\".concat(name1, \" and \").concat(name2, \" are different fields\")], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \".concat(inspect(type1), \" and \").concat(inspect(type2))], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isListType(type2)) {\n    return true;\n  }\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isNonNullType(type2)) {\n    return true;\n  }\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n        break;\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref4) {\n      var reason = _ref4[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref5) {\n      var fields1 = _ref5[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref6) {\n      var fields2 = _ref6[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\nvar PairSet = /*#__PURE__*/\nfunction () {\n  function PairSet() {\n    _defineProperty(this, \"_data\", void 0);\n    this._data = Object.create(null);\n  }\n  var _proto = PairSet.prototype;\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n    return true;\n  };\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n  return PairSet;\n}();\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n  map[b] = areMutuallyExclusive;\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","GraphQLError","inspect","find","Kind","print","getNamedType","isNonNullType","isLeafType","isObjectType","isListType","isInterfaceType","typeFromAST","fieldsConflictMessage","responseName","reason","concat","reasonMessage","Array","isArray","map","_ref","subreason","join","OverlappingFieldsCanBeMerged","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","_i","length","_ref3","_ref2$","fields1","fields2","reportError","parentType","_getFieldsAndFragment","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","comparedFragments","create","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","fragmentName1","fragmentName2","has","add","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","_getFieldsAndFragment2","_getFieldsAndFragment3","_comparedFragments","_i2","_j","_arr","keys","_i3","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","_arr2","_i4","field1","field2","node1","def1","node2","def2","type1","type","type2","name1","name","name2","sameArguments","arguments","doTypesConflict","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","argument","sameValue","value1","value2","ofType","cached","get","nodeAndDefs","_collectFieldsAndFragmentNames","set","fragmentType","getSchema","typeCondition","selections","selection","kind","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref4","reduce","allFields","_ref5","_ref6","_data","_proto","prototype","a","b","first","result","undefined","_pairSetAdd","data"],"sources":["/Users/richa/Desktop/Projects/demo-project/store/bookstore-v2/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.mjs"],"sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport inspect from '../../jsutils/inspect';\nimport find from '../../jsutils/find';\nimport { Kind } from '../../language/kinds';\nimport { print } from '../../language/printer';\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nexport function fieldsConflictMessage(responseName, reason) {\n  return \"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(reason)) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(subreason));\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nexport function OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i = 0; _i < conflicts.length; _i++) {\n        var _ref3 = conflicts[_i];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n\n  comparedFragments[fragmentName] = true;\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i2 = 0; _i2 < fragmentNames1.length; _i2++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i2], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  var _arr = Object.keys(fieldMap);\n\n  for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n    var responseName = _arr[_i3];\n    var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  var _arr2 = Object.keys(fieldMap1);\n\n  for (var _i4 = 0; _i4 < _arr2.length; _i4++) {\n    var responseName = _arr2[_i4];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2); // The return type for each field.\n\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\".concat(name1, \" and \").concat(name2, \" are different fields\")], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \".concat(inspect(type1), \" and \").concat(inspect(type2))], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n        break;\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref4) {\n      var reason = _ref4[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref5) {\n      var fields1 = _ref5[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref6) {\n      var fields2 = _ref6[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet =\n/*#__PURE__*/\nfunction () {\n  function PairSet() {\n    _defineProperty(this, \"_data\", void 0);\n\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}